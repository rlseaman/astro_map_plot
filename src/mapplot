#!/usr/bin/env python3
"""
mapplot - Command-line tool for plotting geographic and celestial data
Usage: mapplot [options] file1.dat [file2.dat ...]
"""

import argparse
import sys
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.markers import MarkerStyle
from matplotlib.patches import Ellipse

try:
    import cartopy.crs as ccrs
    import cartopy.feature as cfeature
except ImportError:
    print("Error: Cartopy is required. Install with: pip install cartopy", file=sys.stderr)
    sys.exit(1)

try:
    from astropy.coordinates import SkyCoord, GeocentricTrueEcliptic, Galactic, ICRS
    from astropy import units as u
    ASTROPY_AVAILABLE = True
except ImportError:
    ASTROPY_AVAILABLE = False

try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False

try:
    from matplotlib.animation import FuncAnimation, FFMpegWriter, PillowWriter
    ANIMATION_AVAILABLE = True
except ImportError:
    ANIMATION_AVAILABLE = False

# Professional color palettes for data series
COLOR_PALETTES = {
    'tableau10': [
        '#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F',
        '#EDC948', '#B07AA1', '#FF9DA7', '#9C755F', '#BAB0AC'
    ],
    'set2': [
        '#66C2A5', '#FC8D62', '#8DA0CB', '#E78AC3', '#A6D854',
        '#FFD92F', '#E5C494', '#B3B3B3'
    ],
    'vibrant': [
        '#EE7733', '#0077BB', '#33BBEE', '#EE3377', '#CC3311',
        '#009988', '#BBBBBB'
    ],
    'muted': [
        '#CC6677', '#332288', '#DDCC77', '#117733', '#88CCEE',
        '#882255', '#44AA99', '#999933', '#AA4499'
    ],
    'default': [
        'red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray'
    ]
}

# Default configuration
DEFAULT_CONFIG = {
    'display': {
        'projection': 'plate-carree',
        'figsize': [12, 8],
        'dpi': 100,
        'bgcolor': 'white',
        'facecolor': None,
    },
    'grid': {
        'spacing': [30, 30],
        'color': 'gray',
        'alpha': 0.5,
        'style': '--',
    },
    'colors': {
        'data_palette': 'tableau10',  # Color palette for data series
        'ecliptic': 'red',             # Reference line colors
        'equator': 'green',
        'galactic': 'blue',
    },
    'celestial': {
        'max_mag': 6.0,
    },
    'paths': {
        'config': '~/.mapplotrc',
        'bsc5_data': '~/.local/share/mapplot/bsc5_data.txt',
        'mpc_observatories': '~/.local/share/mapplot/mpc_observatories.txt',
    }
}

# Define available projections
TERRESTRIAL_PROJECTIONS = {
    'plate-carree': lambda: ccrs.PlateCarree(),
    'mercator': lambda: ccrs.Mercator(),
    'miller': lambda: ccrs.Miller(),
    'mollweide': lambda: ccrs.Mollweide(),
    'robinson': lambda: ccrs.Robinson(),
    'hammer': lambda: ccrs.Hammer(),
    'aitoff': lambda: ccrs.Aitoff(),
    'lambert-conformal': lambda: ccrs.LambertConformal(),
    'lambert-azimuthal': lambda: ccrs.LambertAzimuthalEqualArea(),
    'albers': lambda: ccrs.AlbersEqualArea(),
    'orthographic': lambda: ccrs.Orthographic(),
    'stereographic': lambda: ccrs.Stereographic(),
    'gnomonic': lambda: ccrs.Gnomonic(),
    'north-polar-stereo': lambda: ccrs.NorthPolarStereo(),
    'south-polar-stereo': lambda: ccrs.SouthPolarStereo(),
    'azimuthal-equidistant': lambda: ccrs.AzimuthalEquidistant(),
    'sinusoidal': lambda: ccrs.Sinusoidal(),
    'equal-earth': lambda: ccrs.EqualEarth(),
    'eckert4': lambda: ccrs.EckertIV(),
    'eckert6': lambda: ccrs.EckertVI(),
}

# Define available markers
MARKERS = {
    'circle': 'o', 'square': 's', 'triangle': '^', 'diamond': 'D',
    'plus': '+', 'cross': 'x', 'star': '*', 'pentagon': 'p',
    'hexagon': 'h', 'point': '.', 'pixel': ','
}


def load_config(config_path=None):
    """
    Load configuration from YAML file.
    
    Precedence: DEFAULT_CONFIG → user config file → command-line args
    """
    import copy
    config = copy.deepcopy(DEFAULT_CONFIG)
    
    if not YAML_AVAILABLE:
        return config
    
    # Determine config file path
    if config_path is None:
        config_path = os.path.expanduser(DEFAULT_CONFIG['paths']['config'])
    else:
        config_path = os.path.expanduser(config_path)
    
    # Load config file if it exists
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r') as f:
                user_config = yaml.safe_load(f)
                if user_config:
                    # Deep merge user config into default config
                    for section, values in user_config.items():
                        if section in config and isinstance(values, dict):
                            config[section].update(values)
                        else:
                            config[section] = values
        except Exception as e:
            print(f"Warning: Could not load config file {config_path}: {e}", 
                  file=sys.stderr)
    
    return config


def get_data_colors(palette_name='tableau10', count=8):
    """
    Get a list of colors from a named palette.
    
    Parameters:
    - palette_name: Name of the palette or 'default'
    - count: Number of colors needed
    
    Returns list of color strings
    """
    if palette_name in COLOR_PALETTES:
        palette = COLOR_PALETTES[palette_name]
    else:
        palette = COLOR_PALETTES['tableau10']
    
    # Repeat palette if we need more colors
    if count > len(palette):
        repeats = (count // len(palette)) + 1
        return (palette * repeats)[:count]
    
    return palette[:count]


def get_bright_stars(max_magnitude=6.0):
    """
    Load the Bright Star Catalogue (BSC5).
    Yale Bright Star Catalog, 5th Edition
    http://tdc-www.harvard.edu/catalogs/bsc5.html
    """
    # Try to find BSC5 catalog file
    catalog_file = None
    search_paths = [
        'bsc5_data.txt',
        os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bsc5_data.txt'),
        os.path.expanduser('~/.local/share/mapplot/bsc5_data.txt'),
    ]
    
    for path in search_paths:
        if os.path.exists(path):
            catalog_file = path
            break
    
    # Load from file if found
    if catalog_file:
        catalog = []
        try:
            with open(catalog_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    parts = line.split()
                    if len(parts) >= 5:
                        try:
                            name = parts[1]
                            ra_hours = float(parts[2])
                            dec_deg = float(parts[3])
                            v_mag = float(parts[4])
                            if v_mag <= max_magnitude:
                                ra_deg = ra_hours * 15.0  # Convert hours to degrees
                                catalog.append((name, ra_deg, dec_deg, v_mag))
                        except (ValueError, IndexError):
                            continue
            if catalog:
                print(f"Loaded {len(catalog)} stars from BSC5 (mag ≤ {max_magnitude})", file=sys.stderr)
                return catalog
        except Exception as e:
            print(f"Warning: Error reading BSC5 catalog: {e}", file=sys.stderr)
    
    # Fallback: minimal built-in catalog
    print(f"Using built-in minimal catalog (bsc5_data.txt not found)", file=sys.stderr)
    stars = [
        ("Sirius", 6.752, -16.716, -1.46),
        ("Canopus", 6.399, -52.696, -0.72),
        ("Arcturus", 14.261, 19.182, -0.04),
        ("Vega", 18.615, 38.783, 0.03),
        ("Capella", 5.278, 45.998, 0.08),
        ("Rigel", 5.242, -8.202, 0.12),
        ("Procyon", 7.655, 5.225, 0.38),
        ("Betelgeuse", 5.919, 7.407, 0.50),
        ("Altair", 19.846, 8.868, 0.77),
        ("Aldebaran", 4.598, 16.509, 0.85),
    ]
    
    # Convert RA from hours to degrees and filter by magnitude
    catalog = []
    for name, ra_hours, dec, mag in stars:
        if mag <= max_magnitude:
            ra_deg = ra_hours * 15.0
            catalog.append((name, ra_deg, dec, mag))
    
    return catalog


def ecliptic_path(n_points=360):
    """Generate points along the ecliptic"""
    lon = np.linspace(0, 360, n_points)
    lat = np.zeros(n_points)
    return lon, lat


def galactic_plane_path(n_points=360):
    """Generate points along the galactic plane"""
    l = np.linspace(0, 360, n_points)
    b = np.zeros(n_points)
    return l, b


def celestial_equator_path(n_points=360):
    """Generate points along the celestial equator (equatorial plane)"""
    ra = np.linspace(0, 360, n_points)
    dec = np.zeros(n_points)
    return ra, dec


def get_pole_coordinates(pole_system):
    """
    Get the coordinates of celestial poles in their native system.
    Returns dict with 'north' and 'south' pole coordinates.
    """
    poles = {}
    
    if pole_system == 'equatorial':
        # North and South Celestial Poles in equatorial coordinates
        poles['north'] = {'coord1': 0.0, 'coord2': 90.0, 'name': 'CP'}
        poles['south'] = {'coord1': 0.0, 'coord2': -90.0, 'name': 'CP'}
        poles['color'] = 'green'  # Matches celestial equator
        poles['marker'] = '^'  # triangle for celestial
        
    elif pole_system == 'ecliptic':
        # North and South Ecliptic Poles in ecliptic coordinates
        poles['north'] = {'coord1': 0.0, 'coord2': 90.0, 'name': 'EP'}
        poles['south'] = {'coord1': 0.0, 'coord2': -90.0, 'name': 'EP'}
        poles['color'] = 'red'  # Matches ecliptic
        poles['marker'] = 'x'  # x for ecliptic poles
        
    elif pole_system == 'galactic':
        # North and South Galactic Poles in galactic coordinates
        poles['north'] = {'coord1': 0.0, 'coord2': 90.0, 'name': 'GP'}
        poles['south'] = {'coord1': 0.0, 'coord2': -90.0, 'name': 'GP'}
        poles['color'] = 'blue'  # Matches galactic plane
        poles['marker'] = '+'  # plus for galactic poles
    
    return poles


def milky_way_density_contours():
    """Return approximate Milky Way density contours in galactic coordinates"""
    # Simplified representation of Milky Way structure
    # Returns list of (l, b, width) tuples representing the disk
    contours = []
    
    # Main disk - wider near center, narrower in outer regions
    for l in np.arange(0, 361, 5):
        # Width varies with galactic longitude
        # Wider near center (l ~ 0, 180), narrower elsewhere
        center_dist = min(abs(l), abs(l - 180), abs(l - 360))
        if center_dist < 30:
            width = 25  # Bulge region
        elif center_dist < 90:
            width = 15  # Inner disk
        else:
            width = 10  # Outer disk
        
        contours.append((l, 0, width))
    
    return contours




def transform_coordinates(lon, lat, from_system, to_system):
    """Transform coordinates between different systems"""
    if not ASTROPY_AVAILABLE:
        print("Error: astropy is required for coordinate transformations", file=sys.stderr)
        sys.exit(1)
    
    # Handle wrapping for RA (0-360)
    if from_system == 'equatorial':
        lon = lon % 360
    
    # Create coordinate object based on input system
    if from_system == 'equatorial':
        coords = SkyCoord(ra=lon*u.degree, dec=lat*u.degree, frame='icrs')
    elif from_system == 'ecliptic':
        coords = SkyCoord(lon=lon*u.degree, lat=lat*u.degree, 
                         frame=GeocentricTrueEcliptic)
    elif from_system == 'galactic':
        coords = SkyCoord(l=lon*u.degree, b=lat*u.degree, frame='galactic')
    else:
        raise ValueError(f"Unknown coordinate system: {from_system}")
    
    # Transform to output system
    if to_system == 'equatorial':
        coords_out = coords.icrs
        return coords_out.ra.degree, coords_out.dec.degree
    elif to_system == 'ecliptic':
        coords_out = coords.transform_to(GeocentricTrueEcliptic)
        return coords_out.lon.degree, coords_out.lat.degree
    elif to_system == 'galactic':
        coords_out = coords.galactic
        return coords_out.l.degree, coords_out.b.degree
    else:
        raise ValueError(f"Unknown coordinate system: {to_system}")


def get_sun_position(mjd):
    """
    Get the Sun's ecliptic longitude at a given Modified Julian Date.
    
    Parameters:
    - mjd: Modified Julian Date (float or array)
    
    Returns:
    - sun_lon: Sun's ecliptic longitude in degrees (float or array)
    """
    if not ASTROPY_AVAILABLE:
        print("Error: astropy is required for Sun position calculation", file=sys.stderr)
        sys.exit(1)
    
    from astropy.time import Time
    from astropy.coordinates import get_sun
    
    # Convert MJD to Time object
    time = Time(mjd, format='mjd')
    
    # Get Sun's position
    sun = get_sun(time)
    
    # Convert to ecliptic coordinates
    sun_ecl = sun.transform_to(GeocentricTrueEcliptic)
    
    return sun_ecl.lon.degree


def mjd_to_year(mjd):
    """Convert MJD to decimal calendar year"""
    # J2000.0 epoch: JD 2451545.0 = MJD 51544.5 = 2000 Jan 1.5
    jd = mjd + 2400000.5
    j2000 = 2451545.0  # 2000 Jan 1.5
    days_since_j2000 = jd - j2000
    years_since_j2000 = days_since_j2000 / 365.25
    return 2000.0 + years_since_j2000


def get_current_mjd():
    """Get current MJD from system time"""
    from datetime import datetime
    # MJD 0 = November 17, 1858
    # Calculate days since then
    mjd_epoch = datetime(1858, 11, 17)
    now = datetime.utcnow()
    delta = now - mjd_epoch
    mjd = delta.total_seconds() / 86400.0  # Convert seconds to days
    return mjd


def get_sun_position(mjd):
    """
    Calculate the Sun's position in ecliptic coordinates for a given MJD.
    
    Returns (longitude, latitude) in degrees.
    Latitude is always 0 (sun is on the ecliptic plane by definition).
    
    Uses simple mean longitude approximation, accurate to ~1 degree.
    """
    # J2000.0 epoch (MJD 51544.5 = 2000 Jan 1.5)
    mjd_j2000 = 51544.5
    
    # Days since J2000
    d = mjd - mjd_j2000
    
    # Mean longitude of the sun (degrees)
    # L0 = 280.460° at J2000, advances 0.9856474° per day
    L0 = 280.460  # Mean longitude at epoch
    rate = 0.9856474  # degrees per day
    
    # Calculate mean longitude
    L = L0 + rate * d
    
    # Normalize to 0-360 range
    L = L % 360.0
    
    # Sun is always on the ecliptic plane, so latitude = 0
    return L, 0.0


def mjd_to_year(mjd):
    """
    Convert Modified Julian Date to decimal calendar year.
    
    MJD = JD - 2400000.5
    JD 2451545.0 = 2000 Jan 1.5 (12:00 TT) = MJD 51544.5
    
    Returns decimal year (e.g., 2024.5 for mid-2024)
    """
    # Convert MJD to JD
    jd = mjd + 2400000.5
    
    # J2000.0 epoch
    j2000 = 2451545.0
    
    # Days since J2000
    days_since_j2000 = jd - j2000
    
    # Convert to years (approximate: 365.25 days/year)
    years_since_j2000 = days_since_j2000 / 365.25
    
    # Add to year 2000.0
    year = 2000.0 + years_since_j2000
    
    return year


def compute_solar_relative_coords(mjd, ra, dec, input_coord, solar_center=180.0):
    """
    Convert coordinates to solar-relative ecliptic coordinates.
    
    Parameters:
    - mjd: Modified Julian Date(s)
    - ra: Right ascension or coord1 (degrees)
    - dec: Declination or coord2 (degrees)
    - input_coord: Input coordinate system ('equatorial', 'ecliptic', 'galactic')
    - solar_center: Solar elongation to place at center of plot (degrees, default 180 for opposition)
    
    Returns:
    - rel_lon: Solar-relative ecliptic longitude (degrees)
    - ecl_lat: Ecliptic latitude (degrees)
    """
    # Convert input coordinates to ecliptic
    ecl_lon, ecl_lat = transform_coordinates(ra, dec, input_coord, 'ecliptic')
    
    # Get Sun's ecliptic longitude at the given time(s)
    sun_lon = get_sun_position(mjd)
    
    # Calculate relative longitude (elongation from Sun)
    rel_lon = ecl_lon - sun_lon
    
    # Wrap to -180 to 180
    rel_lon = np.where(rel_lon > 180, rel_lon - 360, rel_lon)
    rel_lon = np.where(rel_lon < -180, rel_lon + 360, rel_lon)
    
    # Adjust for centering
    # Center the specified elongation at lon=0
    # If solar_center=180 (opposition), opposition goes to lon=0
    # If solar_center=0 (conjunction), conjunction goes to lon=0
    plot_lon = rel_lon - solar_center
    
    # Wrap to -180 to 180 for plotting
    plot_lon = np.where(plot_lon > 180, plot_lon - 360, plot_lon)
    plot_lon = np.where(plot_lon < -180, plot_lon + 360, plot_lon)
    
    return plot_lon, ecl_lat


def parse_args():
    parser = argparse.ArgumentParser(
        description='Plot geographic or celestial data with various projections',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Examples:
  # Sky maps (default mode) with BSC5 catalog
  mapplot --catalog -p mollweide -g
  mapplot --catalog --ecliptic --galactic-plane
  
  # Show poles of coordinate systems
  mapplot --catalog --ecliptic --poles ecliptic
  mapplot --catalog --poles all  # Show all poles
  
  # Grid in different coordinate system than data
  mapplot --catalog --plot-coord equatorial --grid-coord galactic -g
  
  # Terrestrial/Earth maps (use --earth flag)
  mapplot --earth cities.txt
  mapplot --earth -p mollweide -g cities.txt
  
  # Show all observatories from Minor Planet Center
  mapplot --earth --observatories -p robinson -g
  
  # Show specific observatories
  mapplot --earth --obs-codes 675 704 G96 -p mercator -g
  
  # Save to file (avoids interactive window)
  mapplot --catalog -o sky.png
  
  # Coordinate transformation
  mapplot --input-coord galactic --plot-coord equatorial data.txt
  
  # Solar-relative coordinates (input: MJD RA Dec)
  mapplot --solar-relative asteroid_track.txt -p mollweide -g
  mapplot --solar-relative --solar-center 90 comet.txt  # Center at quadrature
  
  # Labels from file (third column)
  mapplot --labels-from-file objects.txt
  
  # Grid with axis labels and cardinal directions
  mapplot --catalog -g --grid-labels --cardinal -p plate-carree
  mapplot --earth cities.txt -g --grid-labels --cardinal -p mercator
  
  # Ignore extra columns (use only lon/lat)
  mapplot --ignore-extra data_with_many_columns.txt
  
Tip: Close the plot window to exit cleanly, or use -o FILE to save without displaying.
Default grid spacing is now 30°. Sky mode is the default; use --earth for terrestrial maps.
  
Available projections:
  {', '.join(sorted(TERRESTRIAL_PROJECTIONS.keys()))}
  
Available markers:
  {', '.join(sorted(MARKERS.keys()))}
  
Coordinate systems (for sky mode):
  equatorial (RA, Dec), ecliptic (lon, lat), galactic (l, b)
  
Data format:
  Terrestrial: lon lat [size] [color_value]
  Celestial: coord1 coord2 [size] [color_value]
  Solar-relative: MJD RA Dec [size] [color_value]
        """
    )
    
    # Input files and mode
    parser.add_argument('files', nargs='*', help='Input file(s) with coordinate data')
    parser.add_argument('--earth', action='store_true',
                        help='Earth map mode (terrestrial coordinates) - default is sky mode')
    parser.add_argument('--catalog', action='store_true',
                        help='Show Bright Star Catalogue (BSC5) - http://tdc-www.harvard.edu/catalogs/bsc5.html')
    parser.add_argument('--max-mag', type=float, default=6.0,
                        help='Maximum stellar magnitude for catalog (default: 6.0, BSC5 contains mag ≤ 6.5)')
    
    # Coordinate systems
    parser.add_argument('--input-coord', default='equatorial',
                        choices=['equatorial', 'ecliptic', 'galactic'],
                        help='Input coordinate system (sky mode, default: equatorial)')
    parser.add_argument('--plot-coord', default='equatorial',
                        choices=['equatorial', 'ecliptic', 'galactic'],
                        help='Plot coordinate system (sky mode, default: equatorial)')
    parser.add_argument('--grid-coord', 
                        choices=['equatorial', 'ecliptic', 'galactic'],
                        help='Grid coordinate system (default: same as --plot-coord)')
    
    # Sky map overlays
    parser.add_argument('--ecliptic', action='store_true',
                        help='Show ecliptic plane (sky mode)')
    parser.add_argument('--galactic-plane', action='store_true',
                        help='Show galactic plane (sky mode)')
    parser.add_argument('--celestial-equator', action='store_true',
                        help='Show celestial equator (sky mode)')
    parser.add_argument('--poles', nargs='+',
                        choices=['equatorial', 'ecliptic', 'galactic', 'all'],
                        help='Show coordinate system poles (e.g., --poles ecliptic galactic)')
    parser.add_argument('--milky-way', action='store_true',
                        help='Show Milky Way density (sky mode)')
    
    # Solar-relative coordinates
    parser.add_argument('--solar-relative', action='store_true',
                        help='Use solar-relative ecliptic longitude (input: MJD RA Dec)')
    parser.add_argument('--solar-center', type=float, default=180.0,
                        help='Center plot at this solar elongation in degrees (default: 180 for opposition)')
    
    # Map projection and display
    parser.add_argument('-p', '--projection', default='plate-carree',
                        choices=sorted(TERRESTRIAL_PROJECTIONS.keys()),
                        help='Map projection (default: plate-carree)')
    parser.add_argument('-o', '--output', help='Output file (default: display interactively)')
    
    # Gridlines
    parser.add_argument('-g', '--gridlines', action='store_true',
                        help='Show gridlines')
    parser.add_argument('--grid-spacing', type=float, nargs=2, metavar=('LON', 'LAT'),
                        help='Grid spacing in degrees (lon lat)')
    parser.add_argument('--grid-color', default='gray',
                        help='Grid line color (default: gray)')
    parser.add_argument('--grid-alpha', type=float, default=0.5,
                        help='Grid line transparency (default: 0.5)')
    parser.add_argument('--grid-style', default='--',
                        help='Grid line style (default: --)')
    parser.add_argument('--grid-labels', action='store_true',
                        help='Show axis labels on gridlines')
    parser.add_argument('--cardinal', action='store_true',
                        help='Show cardinal direction markers (N, S, E, W)')
    
    # Map features (terrestrial mode)
    parser.add_argument('--coastlines', action='store_true', default=True,
                        help='Show coastlines (terrestrial mode, default: True)')
    parser.add_argument('--no-coastlines', dest='coastlines', action='store_false',
                        help='Hide coastlines')
    parser.add_argument('--countries', action='store_true',
                        help='Show country boundaries (terrestrial mode)')
    parser.add_argument('--land', action='store_true',
                        help='Fill land areas (terrestrial mode)')
    parser.add_argument('--ocean', action='store_true',
                        help='Fill ocean areas (terrestrial mode)')
    parser.add_argument('--observatories', action='store_true',
                        help='Show observatory locations from MPC (terrestrial mode)')
    parser.add_argument('--obs-codes', nargs='+',
                        help='Specific observatory codes to plot (e.g., 474 809 G96). If not specified, plots all.')
    parser.add_argument('--obs-file', default='mpc_observatories.txt',
                        help='MPC observatory file (default: mpc_observatories.txt)')
    parser.add_argument('--obs-dates-file',
                        help='Observatory operational dates file (Code StartMJD EndMJD format)')
    parser.add_argument('--animate-observatories', action='store_true',
                        help='Animate observatories appearing/disappearing (requires --obs-dates-file)')
    
    # Marker styling
    parser.add_argument('-m', '--marker', default='circle',
                        help=f'Marker style (default: circle)')
    parser.add_argument('-c', '--color', action='append',
                        help='Marker color(s) for each file (can specify multiple times)')
    parser.add_argument('-s', '--size', type=float, default=20,
                        help='Base marker size (default: 20)')
    parser.add_argument('--alpha', type=float, default=0.7,
                        help='Marker transparency (0-1, default: 0.7)')
    parser.add_argument('--edgecolor', default='none',
                        help='Marker edge color (default: none)')
    parser.add_argument('--edgewidth', type=float, default=0.5,
                        help='Marker edge width (default: 0.5)')
    
    # Colormap options
    parser.add_argument('--cmap', default='viridis',
                        help='Colormap for color column (default: viridis)')
    parser.add_argument('--cbar', action='store_true',
                        help='Show colorbar when using color column')
    
    # Background and colors
    parser.add_argument('--bgcolor', default='white',
                        help='Background color (default: white)')
    parser.add_argument('--facecolor', 
                        help='Axes face color (default: same as bgcolor)')
    
    # Figure options
    parser.add_argument('--figsize', type=float, nargs=2, metavar=('WIDTH', 'HEIGHT'),
                        default=[12, 8],
                        help='Figure size in inches (default: 12 8)')
    parser.add_argument('--dpi', type=int, default=100,
                        help='Figure DPI (default: 100)')
    parser.add_argument('--title', help='Plot title (use \\n for multi-line titles)')
    parser.add_argument('--config', help='Path to configuration file (YAML format, default: ~/.mapplotrc)')
    parser.add_argument('--palette', choices=list(COLOR_PALETTES.keys()), 
                        help='Color palette for data series (default: tableau10)')
    parser.add_argument('--extent', type=float, nargs=4,
                        metavar=('LONMIN', 'LONMAX', 'LATMIN', 'LATMAX'),
                        help='Map extent (default: global)')
    
    # Legend
    parser.add_argument('--legend', action='store_true',
                        help='Show legend')
    parser.add_argument('--labels', nargs='+',
                        help='Legend labels for each file')
    parser.add_argument('--labels-from-file', action='store_true',
                        help='Use third column from data files as point labels')
    parser.add_argument('--ignore-extra', action='store_true',
                        help='Ignore all columns beyond first two (lon/lat or coord1/coord2)')
    
    # Animation options
    parser.add_argument('--animate', action='store_true',
                        help='Create animation from time-series data (requires MJD as first column)')
    parser.add_argument('--fps', type=float, default=30,
                        help='Frames per second for animation (default: 30)')
    parser.add_argument('--time-per-day', type=float,
                        help='Seconds per day of data (alternative to --fps, sets animation speed)')
    parser.add_argument('--speed', type=float, default=1.0,
                        help='Animation speed multiplier (default: 1.0, higher=faster)')
    parser.add_argument('--trail-length', type=int,
                        help='Show only last N points (window mode, much faster for large datasets)')
    parser.add_argument('--trail-days', type=float,
                        help='Show only last N days of data (alternative to --trail-length)')
    parser.add_argument('--trail-fade', action='store_true',
                        help='Fade older points in trail (alpha gradient)')
    parser.add_argument('--show-time', action='store_true',
                        help='Display current date/MJD on animation')
    parser.add_argument('--time-format', choices=['mjd', 'year'], default='mjd',
                        help='Time display format: mjd (default) or year (decimal calendar year)')
    parser.add_argument('--highlight-current', action='store_true',
                        help='Make current point larger/different color')
    parser.add_argument('--end-pause', type=float, default=0,
                        help='Seconds to pause at end showing all data (0=no pause, default: 0)')
    parser.add_argument('--legend-loc', default='upper right',
                        choices=['upper right', 'upper left', 'lower right', 'lower left', 
                                'center', 'best'],
                        help='Legend location (default: upper right, fixed position)')
    parser.add_argument('--downsample', type=int, default=100000,
                        help='Auto-downsample if points exceed this (default: 100000, 0=disable)')
    parser.add_argument('--start-time', type=float,
                        help='Animation start time (MJD). If not specified, uses earliest data point.')
    parser.add_argument('--stop-time', type=float,
                        help='Animation stop time (MJD). If not specified, uses current time.')
    parser.add_argument('--show-before-start', action='store_true',
                        help='Show all data points before start-time in first frame (otherwise starts empty)')
    parser.add_argument('--show-sun', action='store_true',
                        help='Show sun position moving along ecliptic during animation (sky mode only)')
    parser.add_argument('--stats-cycles', type=int, default=3,
                        help='Number of trail-day cycles to average for statistics (default: 3, range: 1-15)')
    parser.add_argument('--show-timeline', action='store_true',
                        help='Show timeline plot below main plot (requires --trail-days)')
    parser.add_argument('--timeline-height', type=float, default=0.25,
                        help='Height of timeline plot as fraction of total figure (default: 0.25)')
    parser.add_argument('--timeline-reverse', action='store_true',
                        help='Reverse timeline direction (left-to-right instead of right-to-left)')
    parser.add_argument('--timeline-ylabel', type=str, default='Objects',
                        help='Y-axis label for timeline plot (default: "Objects")')
    parser.add_argument('--timeline-xlabel-years', action='store_true',
                        help='Label timeline x-axis in years instead of MJD')
    parser.add_argument('--show-keyframe', action='store_true',
                        help='Add keyframe showing complete timeline and all objects')
    parser.add_argument('--keyframe-at-start', action='store_true',
                        help='Place keyframe at start instead of end (requires --show-keyframe)')
    parser.add_argument('--keyframe-delay', type=float, default=2.0,
                        help='Seconds to wait before showing keyframe (default: 2.0)')
    
    return parser.parse_args()


def read_data(filename, ignore_extra=False, labels_from_file=False, solar_relative=False, read_mjd=False):
    """Read coordinates and optional size/color/label columns from file
    
    Parameters:
    - filename: path to data file
    - ignore_extra: ignore columns beyond first two (or three if solar_relative/read_mjd)
    - labels_from_file: use third column (or fourth if solar_relative/read_mjd) as labels
    - solar_relative: if True, first column is MJD, then RA/coord1, then Dec/coord2
    - read_mjd: if True, read first column as MJD (for animation, without solar-relative transform)
    
    Returns:
    - coord1, coord2, sizes, colors, labels (or mjd, coord1, coord2, sizes, colors, labels if solar_relative or read_mjd)
    """
    try:
        labels = None
        mjd = None
        
        # Determine if we're reading MJD (either for solar-relative or animation)
        has_mjd = solar_relative or read_mjd
        
        # If we need labels, read differently
        if labels_from_file:
            if has_mjd:
                # Format: MJD RA Dec Label [size] [color]
                mjd_list, coord1_list, coord2_list, labels_list = [], [], [], []
                with open(filename, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if not line or line.startswith('#'):
                            continue
                        parts = line.split()
                        if len(parts) >= 4:
                            mjd_list.append(float(parts[0]))
                            coord1_list.append(float(parts[1]))
                            coord2_list.append(float(parts[2]))
                            labels_list.append(parts[3])
                        elif len(parts) >= 3:
                            mjd_list.append(float(parts[0]))
                            coord1_list.append(float(parts[1]))
                            coord2_list.append(float(parts[2]))
                            labels_list.append('')
                mjd = np.array(mjd_list)
                coord1 = np.array(coord1_list)
                coord2 = np.array(coord2_list)
                labels = labels_list
                sizes = None
                colors = None
            else:
                # Format: RA Dec Label [size] [color]
                coord1_list, coord2_list, labels_list = [], [], []
                with open(filename, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if not line or line.startswith('#'):
                            continue
                        parts = line.split()
                        if len(parts) >= 3:
                            coord1_list.append(float(parts[0]))
                            coord2_list.append(float(parts[1]))
                            labels_list.append(parts[2])
                        elif len(parts) >= 2:
                            coord1_list.append(float(parts[0]))
                            coord2_list.append(float(parts[1]))
                            labels_list.append('')
                coord1 = np.array(coord1_list)
                coord2 = np.array(coord2_list)
                labels = labels_list
                sizes = None
                colors = None
        else:
            # Normal numeric reading
            data = np.loadtxt(filename, comments='#')
            if data.ndim == 1:
                data = data.reshape(1, -1)
            
            if has_mjd:
                # Format: MJD RA Dec [size] [color]
                if data.shape[1] < 3:
                    print(f"Error: {filename} with time data must have at least 3 columns (MJD coord1 coord2)", 
                          file=sys.stderr)
                    sys.exit(1)
                
                mjd = data[:, 0]
                coord1 = data[:, 1]
                coord2 = data[:, 2]
                
                if ignore_extra:
                    sizes = None
                    colors = None
                else:
                    sizes = data[:, 3] if data.shape[1] > 3 else None
                    colors = data[:, 4] if data.shape[1] > 4 else None
            else:
                # Format: RA Dec [size] [color]
                if data.shape[1] < 2:
                    print(f"Error: {filename} must have at least 2 columns", file=sys.stderr)
                    sys.exit(1)
                
                coord1 = data[:, 0]
                coord2 = data[:, 1]
                
                if ignore_extra:
                    sizes = None
                    colors = None
                else:
                    sizes = data[:, 2] if data.shape[1] > 2 else None
                    colors = data[:, 3] if data.shape[1] > 3 else None
        
        return mjd, coord1, coord2, sizes, colors, labels
    except Exception as e:
        print(f"Error reading {filename}: {e}", file=sys.stderr)
        sys.exit(1)


def prepare_animation_data(args, palette_name):
    """
    Prepare and sort data for animation.
    Returns list of dicts with: {'mjd', 'lon', 'lat', 'size', 'color', 'label', 'file_index'}
    """
    all_data = []
    
    # Set up colors for files (use user-specified colors if provided)
    if args.color is None:
        file_colors = get_data_colors(palette_name, len(args.files))
    else:
        file_colors = args.color[:]  # Copy the list
        # Extend with black if not enough colors provided
        if len(file_colors) < len(args.files):
            file_colors.extend(['black'] * (len(args.files) - len(file_colors)))
    
    for file_idx, filename in enumerate(args.files):
        # Read data with MJD (either for animation or solar-relative)
        mjd, lon, lat, sizes, colors, labels = read_data(
            filename, 
            ignore_extra=args.ignore_extra,
            labels_from_file=args.labels_from_file,
            solar_relative=args.solar_relative,
            read_mjd=True  # Animation always needs MJD
        )
        
        if mjd is None:
            print(f"Error: --animate requires MJD as first column in {filename}", file=sys.stderr)
            sys.exit(1)
        
        # Get color for this file
        file_color = file_colors[file_idx]
        
        # Create data records
        for i in range(len(lon)):
            record = {
                'mjd': mjd[i],
                'lon': lon[i],
                'lat': lat[i],
                'size': sizes[i] if sizes is not None else args.size,
                'color': colors[i] if colors is not None else file_color,
                'label': labels[i] if labels is not None else None,
                'file_index': file_idx
            }
            all_data.append(record)
    
    # Sort by MJD
    all_data.sort(key=lambda x: x['mjd'])
    
    # Downsample if needed
    if args.downsample > 0 and len(all_data) > args.downsample:
        step = len(all_data) // args.downsample
        all_data = all_data[::step]
        print(f"Downsampled {len(all_data) * step} points to {len(all_data)}", file=sys.stderr)
    
    return all_data


def create_animation(args, ax, fig, all_data, palette_name, observatories=None, obs_dates=None, ax_timeline=None):
    """
    Create animation using FuncAnimation.
    
    Parameters:
    - observatories: list of observatory dicts with code, lon, lat, name
    - obs_dates: dict mapping code -> {start_mjd, end_mjd}
    - ax_timeline: optional secondary axis for timeline plot
    """
    if not ANIMATION_AVAILABLE:
        print("Error: Animation requires matplotlib.animation", file=sys.stderr)
        print("This should be available with matplotlib. Try: pip install matplotlib --upgrade", file=sys.stderr)
        sys.exit(1)
    
    # Convert marker name to matplotlib code
    marker = MARKERS.get(args.marker, args.marker)
    
    # Calculate time-based animation parameters
    data_mjd_start = all_data[0]['mjd']
    data_mjd_end = all_data[-1]['mjd']
    
    # Use specified start time or earliest data point
    if args.start_time is not None:
        mjd_start = args.start_time
    else:
        mjd_start = data_mjd_start
    
    # Use specified stop time or current time
    if args.stop_time is not None:
        mjd_end = args.stop_time
    else:
        # Default to current time
        mjd_end = get_current_mjd()
        print(f"Using current time as stop: MJD {mjd_end:.2f} ({mjd_to_year(mjd_end):.1f})", 
              file=sys.stderr)
    
    # Ensure stop is after start
    if mjd_end <= mjd_start:
        print(f"Error: Stop time ({mjd_end}) must be after start time ({mjd_start})", 
              file=sys.stderr)
        sys.exit(1)
    
    mjd_span = mjd_end - mjd_start
    
    print(f"Animation time range: MJD {mjd_start:.2f} to {mjd_end:.2f} ({mjd_span:.1f} days)", 
          file=sys.stderr)
    
    if args.time_per_day:
        # Time-based: N seconds per day of data
        total_seconds = mjd_span * args.time_per_day / args.speed
        frames_count = int(total_seconds * args.fps)
        interval = 1000 / args.fps  # ms per frame
        days_per_frame = mjd_span / frames_count
    else:
        # Frame-based: just use fps with speed multiplier
        # Default to showing each data point, but respect speed
        frames_count = len(all_data)
        interval = (1000 / args.fps) / args.speed  # ms per frame, adjusted for speed
        days_per_frame = mjd_span / frames_count
    
    print(f"Animation: {frames_count} frames, {days_per_frame:.2f} days/frame, " + 
          f"{1000/interval:.1f} fps", file=sys.stderr)
    
    # Add end pause frames if requested
    end_pause_frames = 0
    if args.end_pause > 0:
        end_pause_frames = int(args.end_pause * args.fps)
        print(f"End pause: {end_pause_frames} frames ({args.end_pause} sec)", file=sys.stderr)
    
    # Add keyframe if requested
    keyframe_frames = 0
    keyframe_delay_frames = 0
    keyframe_duration = 3.0  # 3 seconds for keyframe
    if args.show_keyframe:
        keyframe_frames = int(keyframe_duration * args.fps)
        keyframe_delay_frames = int(args.keyframe_delay * args.fps)
        print(f"Keyframe: {keyframe_delay_frames} delay frames + {keyframe_frames} keyframe frames " +
              f"({args.keyframe_delay + keyframe_duration} sec total) at " + 
              f"{'start' if args.keyframe_at_start else 'end'}", file=sys.stderr)
    
    # Calculate total frames based on keyframe position
    if args.show_keyframe and args.keyframe_at_start:
        # Start: delay, then keyframe, then animation, then end pause
        total_frames = keyframe_delay_frames + keyframe_frames + frames_count + end_pause_frames
        keyframe_delay_start = 0
        keyframe_start = keyframe_delay_frames
        animation_offset = keyframe_delay_frames + keyframe_frames
    else:
        # End: animation, end pause, delay, then keyframe
        total_frames = frames_count + end_pause_frames + keyframe_delay_frames + keyframe_frames
        keyframe_delay_start = frames_count + end_pause_frames
        keyframe_start = frames_count + end_pause_frames + keyframe_delay_frames
        animation_offset = 0
    
    # Storage for plot artists
    scatter_artists = {}
    time_text = None
    stats_text = None  # For running statistics display
    obs_count_text = None  # For observatory count display
    
    # Window size for statistics and timeline (in units of trail_days)
    max_stats_cycles = max(1, min(15, args.stats_cycles))  # Clamp to 1-15
    
    # Get file colors for timeline stacked plot
    if args.color is None:
        file_colors = get_data_colors(palette_name, len(args.files))
    else:
        file_colors = args.color[:]  # Copy the list
        if len(file_colors) < len(args.files):
            file_colors.extend(['black'] * (len(args.files) - len(file_colors)))
    
    # Storage for timeline data
    timeline_data = []  # List of (mjd, {file_idx: count, ...}) for timeline plot
    timeline_polys = []  # List of PolyCollection objects for stacked timeline
    timeline_started = False  # Track if we've accumulated enough data
    
    # Initialize timeline axis if present
    if ax_timeline is not None:
        # Set x-axis limits from the beginning so labels appear immediately
        if args.timeline_reverse:
            ax_timeline.set_xlim(mjd_start, mjd_end)
        else:
            ax_timeline.set_xlim(mjd_end, mjd_start)  # Reversed (right-to-left)
        
        # Set year formatter if requested
        if args.timeline_xlabel_years:
            from matplotlib.ticker import FuncFormatter
            def mjd_to_year_label(x, pos):
                return f'{mjd_to_year(x):.0f}'  # Integer years
            ax_timeline.xaxis.set_major_formatter(FuncFormatter(mjd_to_year_label))
        
        # Set initial y-limits (will auto-scale as data comes in)
        ax_timeline.set_ylim(0, 100)
    
    # Storage for sun trail (smooth motion)
    sun_trail = []  # List of recent sun positions: [(lon, lat), ...]
    max_sun_trail = 8  # Keep last 8 positions for smooth motion
    
    # Pre-compute MJD lookup table for fast binary search
    mjd_values = np.array([record['mjd'] for record in all_data])
    
    def init_frame():
        """Initialize animation"""
        return []
    
    def update_frame(frame_num):
        """Update function for each frame"""
        nonlocal time_text
        
        # Check if this is in the delay period before keyframe
        is_keyframe_delay = False
        if args.show_keyframe:
            if args.keyframe_at_start and frame_num < keyframe_delay_frames:
                is_keyframe_delay = True
            elif not args.keyframe_at_start and frame_num >= keyframe_delay_start and frame_num < keyframe_start:
                is_keyframe_delay = True
        
        # Check if this is a keyframe
        is_keyframe = False
        if args.show_keyframe:
            if args.keyframe_at_start and frame_num >= keyframe_delay_frames and frame_num < (keyframe_delay_frames + keyframe_frames):
                is_keyframe = True
            elif not args.keyframe_at_start and frame_num >= keyframe_start:
                is_keyframe = True
        
        # Adjust frame_num for animation offset (if keyframe at start)
        if args.show_keyframe and args.keyframe_at_start and not is_keyframe and not is_keyframe_delay:
            adjusted_frame = frame_num - animation_offset
        else:
            adjusted_frame = frame_num - (animation_offset if not is_keyframe and not is_keyframe_delay else 0)
        
        # Handle keyframe delay (pause showing final animation state)
        if is_keyframe_delay:
            # Show final animation frame (with trail applied), not all data
            current_mjd = mjd_end
            show_all = False  # Use trail settings
            show_sun_frame = args.show_sun
        # Handle keyframes (show all data, complete timeline, no sun)
        elif is_keyframe:
            current_mjd = mjd_end
            show_all = True  # Show everything
            show_sun_frame = False
        # Handle end pause frames (show final animation state)
        elif adjusted_frame >= frames_count:
            current_mjd = mjd_end
            show_all = False  # Use trail settings
            show_sun_frame = args.show_sun
        else:
            # Calculate current MJD based on frame number (time-based)
            current_mjd = mjd_start + (adjusted_frame * days_per_frame)
            show_all = False
            show_sun_frame = args.show_sun
        
        # Find all points up to current time using binary search (FAST!)
        if show_all:
            current_idx = len(all_data) - 1
        else:
            # Binary search: O(log n) instead of O(n)
            current_idx = np.searchsorted(mjd_values, current_mjd, side='right') - 1
            if current_idx < 0:
                current_idx = 0
        
        # Determine which points to show
        if show_all:
            # End pause: show everything
            start_idx = 0
            end_idx = len(all_data)
            visible_data = all_data[start_idx:end_idx]
        else:
            # Check if this is first frame and we should show pre-start data
            if frame_num == 0 and args.show_before_start:
                # Show all points before start_time plus points at start_time
                # Find index of first point at or after start_time
                start_time_idx = np.searchsorted(mjd_values, mjd_start, side='left')
                # Show everything from beginning up to current_idx
                start_idx = 0
                end_idx = max(current_idx + 1, start_time_idx)
                visible_data = all_data[start_idx:end_idx]
            else:
                # Normal animation: apply trail if requested
                if args.trail_days:
                    # Time-based trail: show last N days (binary search for start)
                    cutoff_mjd = current_mjd - args.trail_days
                    start_idx = np.searchsorted(mjd_values, cutoff_mjd, side='left')
                elif args.trail_length and current_idx > args.trail_length:
                    # Point-based trail: show last N points
                    start_idx = current_idx - args.trail_length
                else:
                    # Cumulative: show all points up to now
                    start_idx = 0
                
                end_idx = current_idx + 1
                visible_data = all_data[start_idx:end_idx]
        
        if not visible_data:
            return []
        
        # Clear previous scatter plots
        for artist in scatter_artists.values():
            artist.remove()
        scatter_artists.clear()
        
        # Group by file for separate scatter plots
        from collections import defaultdict
        by_file = defaultdict(list)
        for record in visible_data:
            by_file[record['file_index']].append(record)
        
        artists = []
        
        # Plot each file's points - BATCH scatter calls for performance
        for file_idx, records in by_file.items():
            lons = np.array([r['lon'] for r in records])
            lats = np.array([r['lat'] for r in records])
            sizes = np.array([r['size'] for r in records])
            colors = [r['color'] for r in records]
            
            # Calculate alpha values for trail fade
            if args.trail_fade and len(records) > 1:
                # Gradient from 0.2 (oldest) to 1.0 (newest)
                alphas = np.linspace(0.2, 1.0, len(records))
            else:
                alphas = np.full(len(records), 0.7)
            
            # Highlight current point if requested (and not in end pause)
            if args.highlight_current and not show_all and current_idx < len(all_data):
                current_record = all_data[current_idx]
                if file_idx == current_record['file_index']:
                    # Plot all but last with trail (BATCH)
                    if len(lons) > 1:
                        # Create color array with alpha
                        colors_with_alpha = [(mcolors.to_rgb(c) + (alpha,)) 
                                            for c, alpha in zip(colors[:-1], alphas[:-1])]
                        sc = ax.scatter(lons[:-1], lats[:-1], s=sizes[:-1], c=colors_with_alpha,
                                       marker=marker, edgecolors='none',
                                       transform=ccrs.PlateCarree(), zorder=3)
                        scatter_artists[f'file_{file_idx}_trail'] = sc
                        artists.append(sc)
                    
                    # Plot current point larger
                    sc_current = ax.scatter([lons[-1]], [lats[-1]], s=[sizes[-1] * 2], 
                                           c=[colors[-1]], marker=marker, alpha=1.0,
                                           edgecolors='black', linewidths=1,
                                           transform=ccrs.PlateCarree(), zorder=4)
                    scatter_artists[f'file_{file_idx}_current'] = sc_current
                    artists.append(sc_current)
                else:
                    # Other files: plot with trail fade (BATCH)
                    colors_with_alpha = [(mcolors.to_rgb(c) + (alpha,)) 
                                        for c, alpha in zip(colors, alphas)]
                    sc = ax.scatter(lons, lats, s=sizes, c=colors_with_alpha,
                                   marker=marker, edgecolors='none',
                                   transform=ccrs.PlateCarree(), zorder=3)
                    scatter_artists[f'file_{file_idx}'] = sc
                    artists.append(sc)
            else:
                # No highlight or end pause: plot all points with fade (BATCH)
                colors_with_alpha = [(mcolors.to_rgb(c) + (alpha,)) 
                                    for c, alpha in zip(colors, alphas)]
                sc = ax.scatter(lons, lats, s=sizes, c=colors_with_alpha,
                               marker=marker, edgecolors='none',
                               transform=ccrs.PlateCarree(), zorder=3)
                scatter_artists[f'file_{file_idx}'] = sc
                artists.append(sc)
        
        # Plot observatories if animated
        if observatories and obs_dates and args.animate_observatories:
            # Calculate special time windows for observatory visibility
            # Grace period: last year before stop - observatories stay visible
            grace_period_start = mjd_end - 365.25  # 1 year before end
            
            # Fade window: 3 seconds after start - already-expired observatories disappear
            fade_duration_days = 3.0 / (24.0 * 3600.0) * (1000.0 / interval)  # Convert 3 sec to days
            fade_cutoff = mjd_start + fade_duration_days
            
            # Find observatories operational at current_mjd
            active_obs = []
            for obs in observatories:
                code = obs['code'].upper()
                if code in obs_dates:
                    dates = obs_dates[code]
                    obs_start = dates['start_mjd']
                    obs_end = dates['end_mjd']
                    
                    # Check if observatory should be visible
                    # Rule 1: Must have started before current time
                    if obs_start > current_mjd:
                        continue
                    
                    # Rule 2: If expired before animation start, hide after fade period
                    if obs_end < mjd_start and current_mjd > fade_cutoff:
                        continue
                    
                    # Rule 3: If active now OR in grace period, show it
                    if obs_end >= current_mjd or obs_end >= grace_period_start:
                        active_obs.append(obs)
            
            if active_obs:
                obs_lons = [obs['lon'] for obs in active_obs]
                obs_lats = [obs['lat'] for obs in active_obs]
                
                # Plot active observatories
                obs_scatter = ax.scatter(obs_lons, obs_lats, s=50, c='red', 
                                        marker='^', edgecolors='darkred', 
                                        linewidths=1, alpha=0.8,
                                        transform=ccrs.PlateCarree(), zorder=5)
                scatter_artists['observatories'] = obs_scatter
                artists.append(obs_scatter)
                
                # Add labels if not too many
                if len(active_obs) <= 30:
                    for obs in active_obs:
                        obs_label = ax.text(obs['lon'], obs['lat'], f" {obs['code']}", 
                                           fontsize=6, ha='left', va='center',
                                           transform=ccrs.PlateCarree(), zorder=6,
                                           bbox=dict(boxstyle='round,pad=0.2', 
                                                   facecolor='white', alpha=0.7,
                                                   edgecolor='none'))
                        scatter_artists[f"obs_label_{obs['code']}"] = obs_label
                        artists.append(obs_label)
            
            # Display observatory count (lower right corner)
            nonlocal obs_count_text
            if obs_count_text:
                obs_count_text.remove()
            
            obs_count = len(active_obs)
            obs_count_str = f'total: {obs_count}'
            
            obs_count_text = ax.text(0.98, 0.02, obs_count_str,
                                    transform=ax.transAxes, fontsize=10,
                                    verticalalignment='bottom', horizontalalignment='right',
                                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.9),
                                    zorder=100)
            artists.append(obs_count_text)
        
        # Plot sun position if requested (sky mode only, not in keyframes)
        if show_sun_frame and not args.earth:
            # Calculate sun's ecliptic position at current time
            sun_lon, sun_lat = get_sun_position(current_mjd)
            
            # Transform to plot coordinates if needed
            if args.plot_coord == 'ecliptic':
                plot_sun_lon, plot_sun_lat = sun_lon, sun_lat
            else:
                # Transform from ecliptic to plot coordinates
                plot_sun_lon, plot_sun_lat = transform_coordinates(
                    np.array([sun_lon]), np.array([sun_lat]), 
                    'ecliptic', args.plot_coord
                )
                plot_sun_lon, plot_sun_lat = plot_sun_lon[0], plot_sun_lat[0]
            
            # Adjust for plotting (wrap longitude for certain projections)
            if args.projection in ['mollweide', 'hammer', 'aitoff']:
                plot_sun_lon = plot_sun_lon - 360 if plot_sun_lon > 180 else plot_sun_lon
            
            # Add current position to trail
            sun_trail.append((plot_sun_lon, plot_sun_lat))
            
            # Keep only last N positions for smooth motion
            if len(sun_trail) > max_sun_trail:
                sun_trail.pop(0)
            
            # Plot sun trail for smooth motion (older positions with lower opacity)
            if len(sun_trail) > 1:
                for i, (trail_lon, trail_lat) in enumerate(sun_trail[:-1]):
                    # Alpha increases from 0.15 to 0.4 as we approach current position
                    alpha = 0.15 + (i / max(len(sun_trail) - 2, 1)) * 0.25
                    size = 60 + (i / max(len(sun_trail) - 2, 1)) * 30  # Size grows: 60 to 90
                    
                    trail_scatter = ax.scatter([trail_lon], [trail_lat], 
                                              s=size, c='yellow', marker='o',
                                              edgecolors='orange', linewidths=1.0,
                                              alpha=alpha, transform=ccrs.PlateCarree(), 
                                              zorder=9)  # Behind current sun
                    scatter_artists[f'sun_trail_{i}'] = trail_scatter
                    artists.append(trail_scatter)
            
            # Plot current sun position (bright and full size)
            # Label added to static legend before animation starts
            sun_scatter = ax.scatter([plot_sun_lon], [plot_sun_lat], 
                                    s=100, c='yellow', marker='o',
                                    edgecolors='orange', linewidths=1.5,
                                    alpha=1.0, transform=ccrs.PlateCarree(), 
                                    zorder=10)
            scatter_artists['sun'] = sun_scatter
            artists.append(sun_scatter)
        
        # Update time display
        if args.show_time and not show_all:  # Don't show time during end pause
            if time_text:
                time_text.remove()
            
            # Format time based on user preference
            if args.time_format == 'year':
                year = mjd_to_year(current_mjd)
                time_str = f'Year: {year:.3f}'
            else:  # mjd
                time_str = f'MJD: {current_mjd:.2f}'
            
            time_text = ax.text(0.02, 0.98, time_str,
                               transform=ax.transAxes, fontsize=12,
                               verticalalignment='top',
                               bbox=dict(boxstyle='round', facecolor='white', alpha=0.9),
                               zorder=100)
            artists.append(time_text)
        
        # Update statistics display (only when using trail-days mode)
        if args.trail_days and args.labels and not show_all:
            nonlocal stats_text
            if stats_text:
                stats_text.remove()
            
            # Calculate FULL rolling window: trail_days × stats_cycles
            full_window_days = args.trail_days * max_stats_cycles
            cutoff_mjd = current_mjd - full_window_days
            
            # Count objects in FULL window (not just visible_data)
            window_start_idx = np.searchsorted(mjd_values, cutoff_mjd, side='left')
            window_end_idx = current_idx + 1
            window_data = all_data[window_start_idx:window_end_idx]
            
            # Count objects per file in FULL window
            from collections import defaultdict
            file_counts = defaultdict(int)
            for record in window_data:
                file_counts[record['file_index']] += 1
            
            total_count = len(window_data)
            
            # Build statistics string with TOTAL (not average)
            # Show window size in days for clarity
            window_info = f'({full_window_days:.0f} day window)'
            stats_lines = [f'Objects: {total_count} {window_info}']
            
            # Add per-file statistics if there are multiple files
            # Show only percentages (no counts, no parentheses, rounded)
            if len(args.labels) > 1:
                for i, label in enumerate(args.labels):
                    count = file_counts.get(i, 0)
                    if total_count > 0:
                        fraction = count / total_count
                        percentage = int(round(fraction * 100))  # Round to whole number
                        stats_lines.append(f'{label}: {percentage}%')
                    else:
                        stats_lines.append(f'{label}: 0%')
            
            stats_str = '\n'.join(stats_lines)
            
            # Display statistics box (upper right corner - opposite from time)
            stats_text = ax.text(0.98, 0.98, stats_str,
                                transform=ax.transAxes, fontsize=10,
                                verticalalignment='top', horizontalalignment='right',
                                bbox=dict(boxstyle='round', facecolor='white', alpha=0.9),
                                zorder=100)
            artists.append(stats_text)
        
        # For keyframe, show stats with ALL data (including before start_time)
        elif is_keyframe and args.labels:
            nonlocal stats_text
            if stats_text:
                stats_text.remove()
            
            # Count all objects per file (including before start_time)
            from collections import defaultdict
            file_counts = defaultdict(int)
            for record in all_data:
                file_counts[record['file_index']] += 1
            
            total_count = len(all_data)
            
            # Build statistics string showing total and fractions
            stats_lines = [f'Total: {total_count}']
            
            # Add per-file statistics
            if len(args.labels) > 1:
                for i, label in enumerate(args.labels):
                    count = file_counts.get(i, 0)
                    if total_count > 0:
                        fraction = count / total_count
                        percentage = int(round(fraction * 100))
                        stats_lines.append(f'{label}: {count} ({percentage}%)')
                    else:
                        stats_lines.append(f'{label}: 0 (0%)')
            
            stats_str = '\n'.join(stats_lines)
            
            # Display statistics box
            stats_text = ax.text(0.98, 0.98, stats_str,
                                transform=ax.transAxes, fontsize=10,
                                verticalalignment='top', horizontalalignment='right',
                                bbox=dict(boxstyle='round', facecolor='white', alpha=0.9),
                                zorder=100)
            artists.append(stats_text)
        
        # Update timeline plot if requested
        if ax_timeline is not None and args.trail_days and not show_all:
            nonlocal timeline_data, timeline_polys, timeline_started
            
            # Calculate FULL rolling window: trail_days × stats_cycles
            window_days = args.trail_days * max_stats_cycles
            cutoff_mjd = current_mjd - window_days
            
            # Count objects in FULL window per file
            window_start_idx = np.searchsorted(mjd_values, cutoff_mjd, side='left')
            window_end_idx = current_idx + 1
            window_data = all_data[window_start_idx:window_end_idx]
            
            # Count by file
            from collections import defaultdict
            file_counts = defaultdict(int)
            for record in window_data:
                file_counts[record['file_index']] += 1
            
            # Add current data point with per-file counts
            timeline_data.append((current_mjd, dict(file_counts)))
            
            # Check if we have enough data to start plotting
            # Start after first complete window
            if not timeline_started and len(timeline_data) > 0:
                first_mjd = timeline_data[0][0]
                if current_mjd - first_mjd >= window_days:
                    timeline_started = True
            
            # Plot timeline if started or if this is a keyframe
            if timeline_started or is_keyframe:
                # Extract MJD and per-file counts
                mjds = [d[0] for d in timeline_data]
                
                # Build arrays for each file
                n_files = len(args.files) if args.files else 0
                file_data = []
                for file_idx in range(n_files):
                    counts = [d[1].get(file_idx, 0) for d in timeline_data]
                    file_data.append(counts)
                
                # Clear previous plots
                for poly in timeline_polys:
                    poly.remove()
                timeline_polys.clear()
                
                # Plot as stacked area if multiple files, otherwise simple line
                if n_files > 1 and args.labels:
                    # Stacked area plot showing proportions
                    polys = ax_timeline.stackplot(mjds, *file_data, 
                                                  colors=file_colors[:n_files],
                                                  alpha=0.7)
                    timeline_polys.extend(polys)
                    artists.extend(polys)
                else:
                    # Single file: just plot total as line
                    total_counts = [sum(d[1].values()) for d in timeline_data]
                    line, = ax_timeline.plot(mjds, total_counts, 'b-', linewidth=1.5)
                    timeline_polys.append(line)
                    artists.append(line)
                
                # Auto-scale y-axis with some padding
                if timeline_data:
                    max_count = max(sum(d[1].values()) for d in timeline_data)
                    ax_timeline.set_ylim(0, max_count * 1.1)
        
        return artists
    
    # Create animation
    print(f"Creating animation: {total_frames} frames at {1000/interval:.1f} fps", file=sys.stderr)
    anim = FuncAnimation(fig, update_frame, frames=total_frames,
                        init_func=init_frame, blit=False, interval=interval,
                        repeat=True)
    
    return anim


def plot_sky_map(ax, args):
    """Plot celestial data on sky map"""
    
    # Set background color
    if args.facecolor:
        ax.set_facecolor(args.facecolor)
    else:
        ax.set_facecolor(args.bgcolor)
    
    # Plot built-in star catalog if requested
    if args.catalog:
        stars = get_bright_stars(args.max_mag)
        ra_list, dec_list, mag_list = [], [], []
        
        for name, ra, dec, mag in stars:
            ra_list.append(ra)
            dec_list.append(dec)
            mag_list.append(mag)
        
        ra_arr = np.array(ra_list)
        dec_arr = np.array(dec_list)
        mag_arr = np.array(mag_list)
        
        # Transform to plot coordinates if needed
        if args.plot_coord != 'equatorial':
            ra_arr, dec_arr = transform_coordinates(
                ra_arr, dec_arr, 'equatorial', args.plot_coord
            )
        
        # Adjust RA for plotting (0-360 or -180 to 180)
        if args.projection in ['mollweide', 'hammer', 'aitoff']:
            ra_arr = np.where(ra_arr > 180, ra_arr - 360, ra_arr)
        
        # Size inversely proportional to magnitude (brighter = bigger)
        sizes = 100 * 10**(-mag_arr / 2.5)
        
        ax.scatter(ra_arr, dec_arr, s=sizes, c='yellow', marker='*',
                  edgecolors='orange', linewidths=0.5, alpha=0.9,
                  transform=ccrs.PlateCarree(), zorder=3,
                  label=f'BSC5 (mag ≤ {args.max_mag})')
    
    # Plot Milky Way density if requested
    if args.milky_way:
        contours = milky_way_density_contours()
        for l, b, width in contours:
            # Create points above and below galactic plane
            b_range = np.linspace(-width, width, 20)
            l_array = np.full_like(b_range, l)
            
            # Transform to plot coordinates
            if args.plot_coord == 'galactic':
                plot_l, plot_b = l_array, b_range
            else:
                plot_l, plot_b = transform_coordinates(
                    l_array, b_range, 'galactic', args.plot_coord
                )
            
            # Adjust for plotting
            if args.projection in ['mollweide', 'hammer', 'aitoff']:
                plot_l = np.where(plot_l > 180, plot_l - 360, plot_l)
            
            # Plot as semi-transparent region
            ax.fill(plot_l, plot_b, color='gray', alpha=0.03,
                   transform=ccrs.PlateCarree(), zorder=1)
    
    # Plot ecliptic
    if args.ecliptic:
        # In solar-relative mode, ecliptic is just a horizontal line at lat=0
        if args.solar_relative:
            # Simple horizontal line across the plot
            ecl_lon = np.linspace(-180, 180, 360)
            ecl_lat = np.zeros_like(ecl_lon)
            ax.plot(ecl_lon, ecl_lat, color='red', linewidth=1.5, alpha=0.7,
                   transform=ccrs.PlateCarree(), label='Ecliptic')
        else:
            # Normal ecliptic plotting for non-solar-relative modes
            ecl_lon, ecl_lat = ecliptic_path(n_points=720)  # Higher resolution
            
            # Transform to plot coordinates if needed
            if args.plot_coord == 'ecliptic':
                plot_lon, plot_lat = ecl_lon, ecl_lat
            else:
                plot_lon, plot_lat = transform_coordinates(
                    ecl_lon, ecl_lat, 'ecliptic', args.plot_coord
                )
            
            # Adjust for plotting
            if args.projection in ['mollweide', 'hammer', 'aitoff']:
                plot_lon = np.where(plot_lon > 180, plot_lon - 360, plot_lon)
            
            # Split line at discontinuities to avoid artifacts
            dl = np.diff(plot_lon)
            breaks = np.where(np.abs(dl) > 180)[0]
            
            # Plot in segments
            if len(breaks) > 0:
                start = 0
                for break_point in breaks:
                    ax.plot(plot_lon[start:break_point+1], plot_lat[start:break_point+1], 
                           color='red', linewidth=1.5, alpha=0.7,
                           transform=ccrs.PlateCarree())
                    start = break_point + 1
                # Plot final segment
                ax.plot(plot_lon[start:], plot_lat[start:], 
                       color='red', linewidth=1.5, alpha=0.7,
                       transform=ccrs.PlateCarree(), label='Ecliptic')
            else:
                ax.plot(plot_lon, plot_lat, color='red', linewidth=1.5, alpha=0.7,
                       transform=ccrs.PlateCarree(), label='Ecliptic')
    
    # Plot galactic plane
    if args.galactic_plane:
        gal_l, gal_b = galactic_plane_path(n_points=720)  # Higher resolution
        
        # Transform to plot coordinates if needed
        if args.plot_coord == 'galactic':
            plot_l, plot_b = gal_l, gal_b
        else:
            plot_l, plot_b = transform_coordinates(
                gal_l, gal_b, 'galactic', args.plot_coord
            )
        
        # Adjust for plotting
        if args.projection in ['mollweide', 'hammer', 'aitoff']:
            plot_l = np.where(plot_l > 180, plot_l - 360, plot_l)
        
        # Split line at discontinuities to avoid artifacts
        # Find where there are large jumps (wrap-around points)
        dl = np.diff(plot_l)
        breaks = np.where(np.abs(dl) > 180)[0]
        
        # Plot in segments
        if len(breaks) > 0:
            start = 0
            for break_point in breaks:
                ax.plot(plot_l[start:break_point+1], plot_b[start:break_point+1], 
                       color='blue', linewidth=1.5, alpha=0.7,
                       transform=ccrs.PlateCarree())
                start = break_point + 1
            # Plot final segment
            ax.plot(plot_l[start:], plot_b[start:], 
                   color='blue', linewidth=1.5, alpha=0.7,
                   transform=ccrs.PlateCarree(), label='Galactic Plane')
        else:
            ax.plot(plot_l, plot_b, color='blue', linewidth=1.5, alpha=0.7,
                   transform=ccrs.PlateCarree(), label='Galactic Plane')
        
        # Plot galactic center with tilted ellipse (perspective view)
        gc_l, gc_b = 0.0, 0.0  # Galactic center is at l=0, b=0
        
        # Transform to plot coordinates if needed
        if args.plot_coord == 'galactic':
            gc_plot_l, gc_plot_b = gc_l, gc_b
        else:
            gc_plot_l, gc_plot_b = transform_coordinates(
                np.array([gc_l]), np.array([gc_b]), 'galactic', args.plot_coord
            )
            gc_plot_l, gc_plot_b = gc_plot_l[0], gc_plot_b[0]
        
        # Adjust for plotting
        if args.projection in ['mollweide', 'hammer', 'aitoff']:
            gc_plot_l = gc_plot_l - 360 if gc_plot_l > 180 else gc_plot_l
        
        # Import Ellipse for tilted outline
        from matplotlib.patches import Ellipse
        from matplotlib.legend_handler import HandlerPatch
        
        # First plot fuzzy white interior (keep as circle)
        ax.scatter(gc_plot_l, gc_plot_b, s=100, c='white', 
                  marker='o', alpha=0.5,
                  transform=ccrs.PlateCarree(), zorder=4)
        
        # Create tilted ellipse outline (represents disk viewed at angle)
        # Reduced size by ~1/3: 12→8, 7→5
        ellipse = Ellipse((gc_plot_l, gc_plot_b), width=8, height=5, 
                         angle=30, facecolor='none', 
                         edgecolor='blue', linewidth=1.5, alpha=0.9,
                         transform=ccrs.PlateCarree(), zorder=4)
        ax.add_patch(ellipse)
        
        # Create proxy ellipse for legend
        from matplotlib.patches import Ellipse as LegendEllipse
        legend_ellipse = LegendEllipse((0, 0), width=1, height=0.6, 
                                       angle=30, facecolor='none',
                                       edgecolor='blue', linewidth=1.5,
                                       label='Galactic Center')
        
        # Custom handler to draw ellipse with center dot in legend
        class EllipseHandler(HandlerPatch):
            def create_artists(self, legend, orig_handle,
                             xdescent, ydescent, width, height, fontsize, trans):
                # Create small ellipse for legend
                center = 0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent
                p = Ellipse(xy=center, width=width * 0.8, height=height * 0.5,
                           angle=30, facecolor='none', edgecolor='blue', 
                           linewidth=1.5, transform=trans)
                # Add center dot
                from matplotlib.patches import Circle
                dot = Circle(xy=center, radius=width * 0.08, 
                           facecolor='blue', edgecolor='none',
                           transform=trans, zorder=10)
                return [p, dot]
        
        # Add proxy to axes (invisible, off-map) for legend to find
        ax.add_artist(legend_ellipse)
        
        # Store handler and proxy for legend creation
        if not hasattr(ax, '_gc_legend_handler'):
            ax._gc_legend_handler = {legend_ellipse: EllipseHandler()}
            ax._gc_legend_proxy = legend_ellipse
        
        # Add center dot for bullseye/target effect
        ax.scatter(gc_plot_l, gc_plot_b, s=15, c='blue', 
                  marker='o', alpha=0.9,
                  transform=ccrs.PlateCarree(), zorder=5)
    
    # Plot celestial equator
    if args.celestial_equator:
        eq_ra, eq_dec = celestial_equator_path(n_points=720)
        
        # Transform to plot coordinates if needed
        if args.plot_coord == 'equatorial':
            plot_ra, plot_dec = eq_ra, eq_dec
        else:
            plot_ra, plot_dec = transform_coordinates(
                eq_ra, eq_dec, 'equatorial', args.plot_coord
            )
        
        # Adjust for plotting
        if args.projection in ['mollweide', 'hammer', 'aitoff']:
            plot_ra = np.where(plot_ra > 180, plot_ra - 360, plot_ra)
        
        # Split line at discontinuities
        dl = np.diff(plot_ra)
        breaks = np.where(np.abs(dl) > 180)[0]
        
        if len(breaks) > 0:
            start = 0
            for break_point in breaks:
                ax.plot(plot_ra[start:break_point+1], plot_dec[start:break_point+1], 
                       color='green', linewidth=1.5, alpha=0.7,
                       transform=ccrs.PlateCarree())
                start = break_point + 1
            ax.plot(plot_ra[start:], plot_dec[start:], 
                   color='green', linewidth=1.5, alpha=0.7,
                   transform=ccrs.PlateCarree(), label='Celestial Equator')
        else:
            ax.plot(plot_ra, plot_dec, color='green', linewidth=1.5, alpha=0.7,
                   transform=ccrs.PlateCarree(), label='Celestial Equator')
    
    # Plot poles
    if args.poles:
        pole_systems = []
        if 'all' in args.poles:
            pole_systems = ['equatorial', 'ecliptic', 'galactic']
        else:
            pole_systems = args.poles
        
        for pole_system in pole_systems:
            poles = get_pole_coordinates(pole_system)
            
            for pole_name in ['north', 'south']:
                pole = poles[pole_name]
                coord1, coord2 = pole['coord1'], pole['coord2']
                
                # Transform to plot coordinates if needed
                if pole_system != args.plot_coord:
                    coord1_arr = np.array([coord1])
                    coord2_arr = np.array([coord2])
                    coord1_arr, coord2_arr = transform_coordinates(
                        coord1_arr, coord2_arr, pole_system, args.plot_coord
                    )
                    coord1, coord2 = coord1_arr[0], coord2_arr[0]
                
                # Adjust for plotting
                if args.projection in ['mollweide', 'hammer', 'aitoff']:
                    coord1 = coord1 - 360 if coord1 > 180 else coord1
                
                # Plot pole
                label = f"{pole['name']}" if pole_name == 'north' else None
                
                # Adjust marker size - ecliptic poles (x) are smaller
                marker_size = 120 if poles['marker'] == 'x' else 150
                
                # Unfilled markers (x, +) don't support edgecolors
                # Only use edgecolors for filled markers
                if poles['marker'] in ['x', '+']:
                    # Unfilled markers - just use color
                    ax.scatter(coord1, coord2, s=marker_size, c=poles['color'], 
                              marker=poles['marker'], linewidths=1.5,
                              alpha=0.9, transform=ccrs.PlateCarree(), zorder=4,
                              label=label)
                else:
                    # Filled markers - use edgecolors
                    ax.scatter(coord1, coord2, s=marker_size, c=poles['color'], 
                              marker=poles['marker'], edgecolors='black', linewidths=1.5,
                              alpha=0.9, transform=ccrs.PlateCarree(), zorder=4,
                              label=label)
    
    return True


def plot_cardinal_directions(ax, args):
    """
    Add cardinal direction markers (N, S, E, W) to the plot.
    
    Position depends on mode:
    - Earth mode: N=top, S=bottom, E=right, W=left (right-handed)
    - Sky mode: N=top, S=bottom, E=LEFT, W=right (left-handed, astronomical convention)
    """
    # For terrestrial/Earth mode (right-handed)
    if args.earth:
        # Add labels at the edges
        ax.text(0, 88, 'N', ha='center', va='center', fontsize=14, fontweight='bold',
               transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
        ax.text(0, -88, 'S', ha='center', va='center', fontsize=14, fontweight='bold',
               transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
        ax.text(178, 0, 'E', ha='center', va='center', fontsize=14, fontweight='bold',
               transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
        ax.text(-178, 0, 'W', ha='center', va='center', fontsize=14, fontweight='bold',
               transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
    else:
        # For sky mode (left-handed, astronomical convention)
        # After x-axis inversion, positive longitude appears on left
        # So E (which should be on left in celestial coords) goes at positive longitude
        if args.solar_relative:
            # In solar-relative mode:
            # "North" = +ecliptic latitude, "South" = -ecliptic latitude
            # "East" = LEFT (trailing, after inversion), "West" = RIGHT (leading, after inversion)
            ax.text(0, 88, 'N', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
            ax.text(0, -88, 'S', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
            # E on left (positive lon before inversion, appears left after)
            ax.text(178, 0, 'E', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
            # W on right (negative lon before inversion, appears right after)
            ax.text(-178, 0, 'W', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
        else:
            # Standard celestial coordinates (left-handed)
            # N = +Dec/+lat (top), S = -Dec/-lat (bottom)
            # E = LEFT (increasing RA/lon), W = RIGHT (decreasing RA/lon)
            ax.text(0, 88, 'N', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
            ax.text(0, -88, 'S', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
            
            # E/W markers for celestial coordinates (left-handed)
            # E on LEFT (positive lon appears left after x-axis inversion)
            ax.text(178, 0, 'E', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)
            # W on RIGHT (negative lon appears right after x-axis inversion)
            ax.text(-178, 0, 'W', ha='center', va='center', fontsize=14, fontweight='bold',
                   transform=ccrs.PlateCarree(), bbox=dict(boxstyle='circle', facecolor='white', alpha=0.9), zorder=100)


def plot_custom_gridlines(ax, grid_coord, plot_coord, grid_spacing, args):
    """
    Plot gridlines in a different coordinate system.
    
    Parameters:
    - grid_coord: coordinate system for the grid
    - plot_coord: coordinate system for plotting
    - grid_spacing: tuple of (lon_spacing, lat_spacing)
    """
    lon_spacing, lat_spacing = grid_spacing
    
    # Generate gridlines in the grid coordinate system
    # Longitude lines (constant longitude, varying latitude)
    for lon in np.arange(0, 360, lon_spacing):
        lat_vals = np.linspace(-90, 90, 180)
        lon_vals = np.full_like(lat_vals, lon)
        
        # Transform to plot coordinates if different
        if grid_coord != plot_coord:
            lon_vals, lat_vals = transform_coordinates(
                lon_vals, lat_vals, grid_coord, plot_coord
            )
        
        # Adjust for certain projections
        if args.projection in ['mollweide', 'hammer', 'aitoff']:
            lon_vals = np.where(lon_vals > 180, lon_vals - 360, lon_vals)
        
        # Plot, splitting at discontinuities
        dl = np.diff(lon_vals)
        breaks = np.where(np.abs(dl) > 180)[0]
        
        if len(breaks) > 0:
            start = 0
            for break_point in breaks:
                ax.plot(lon_vals[start:break_point+1], lat_vals[start:break_point+1],
                       color=args.grid_color, linewidth=0.5, alpha=args.grid_alpha,
                       linestyle=args.grid_style, transform=ccrs.PlateCarree(), zorder=0.5)
                start = break_point + 1
            ax.plot(lon_vals[start:], lat_vals[start:],
                   color=args.grid_color, linewidth=0.5, alpha=args.grid_alpha,
                   linestyle=args.grid_style, transform=ccrs.PlateCarree(), zorder=0.5)
        else:
            ax.plot(lon_vals, lat_vals, color=args.grid_color, linewidth=0.5,
                   alpha=args.grid_alpha, linestyle=args.grid_style,
                   transform=ccrs.PlateCarree(), zorder=0.5)
    
    # Latitude lines (constant latitude, varying longitude)
    for lat in np.arange(-90, 91, lat_spacing):
        if abs(lat) > 89:  # Skip poles
            continue
        lon_vals = np.linspace(0, 360, 360)
        lat_vals = np.full_like(lon_vals, lat)
        
        # Transform to plot coordinates if different
        if grid_coord != plot_coord:
            lon_vals, lat_vals = transform_coordinates(
                lon_vals, lat_vals, grid_coord, plot_coord
            )
        
        # Adjust for certain projections
        if args.projection in ['mollweide', 'hammer', 'aitoff']:
            lon_vals = np.where(lon_vals > 180, lon_vals - 360, lon_vals)
        
        # Plot, splitting at discontinuities
        dl = np.diff(lon_vals)
        breaks = np.where(np.abs(dl) > 180)[0]
        
        if len(breaks) > 0:
            start = 0
            for break_point in breaks:
                ax.plot(lon_vals[start:break_point+1], lat_vals[start:break_point+1],
                       color=args.grid_color, linewidth=0.5, alpha=args.grid_alpha,
                       linestyle=args.grid_style, transform=ccrs.PlateCarree(), zorder=0.5)
                start = break_point + 1
            ax.plot(lon_vals[start:], lat_vals[start:],
                   color=args.grid_color, linewidth=0.5, alpha=args.grid_alpha,
                   linestyle=args.grid_style, transform=ccrs.PlateCarree(), zorder=0.5)
        else:
            ax.plot(lon_vals, lat_vals, color=args.grid_color, linewidth=0.5,
                   alpha=args.grid_alpha, linestyle=args.grid_style,
                   transform=ccrs.PlateCarree(), zorder=0.5)


def download_mpc_observatories(url=None):
    """
    Download observatory codes from Minor Planet Center.
    
    Returns observatory data as list of dicts with:
    - code: 3-character observatory code
    - lon: longitude in degrees (-180 to 180)
    - lat: latitude in degrees
    - name: observatory name
    """
    if url is None:
        url = "https://www.minorplanetcenter.net/iau/lists/ObsCodesF.html"
    
    try:
        import urllib.request
        response = urllib.request.urlopen(url, timeout=30)
        content = response.read().decode('utf-8')
        return parse_mpc_observatories(content)
    except Exception as e:
        print(f"Warning: Could not download MPC observatories: {e}", file=sys.stderr)
        return []


def parse_mpc_observatories(content):
    """
    Parse MPC observatory codes from file content.
    
    Format is fixed-width:
    Code Longitude rho*cos(phi) rho*sin(phi) Name
    
    where phi is geocentric latitude, rho is Earth radii
    """
    observatories = []
    
    for line in content.split('\n'):
        line = line.strip()
        if not line or len(line) < 30:
            continue
        
        # Skip HTML tags if present
        if '<' in line or '>' in line:
            continue
        
        try:
            # Parse fixed-width format
            code = line[0:3].strip()
            if not code or not code.replace('.', '').isalnum():
                continue
            
            # Extract values
            lon_str = line[4:13].strip()
            rho_cos_str = line[14:21].strip()
            rho_sin_str = line[22:30].strip()
            name = line[30:].strip()
            
            if not lon_str or not rho_cos_str or not rho_sin_str:
                continue
            
            lon = float(lon_str)
            rho_cos = float(rho_cos_str)
            rho_sin = float(rho_sin_str)
            
            # Convert to latitude using arctan2
            # geocentric latitude = arctan2(sin, cos)
            lat = np.degrees(np.arctan2(rho_sin, rho_cos))
            
            # Convert longitude to -180 to 180 range
            if lon > 180:
                lon = lon - 360
            
            observatories.append({
                'code': code,
                'lon': lon,
                'lat': lat,
                'name': name if name else f"Observatory {code}"
            })
            
        except (ValueError, IndexError):
            continue
    
    return observatories


def load_mpc_observatories(obs_file=None):
    """Load MPC observatories from file or download"""
    
    # Try to find file
    if obs_file:
        # Try as-is
        if os.path.exists(obs_file):
            pass
        # Try in package data directory
        elif os.path.exists(os.path.join(os.path.dirname(__file__), obs_file)):
            obs_file = os.path.join(os.path.dirname(__file__), obs_file)
        # Try in user data directory
        elif obs_file == 'mpc_observatories.txt':
            user_path = os.path.expanduser('~/.local/share/mapplot/mpc_observatories.txt')
            if os.path.exists(user_path):
                obs_file = user_path
    
    if obs_file and os.path.exists(obs_file):
        try:
            with open(obs_file, 'r') as f:
                content = f.read()
            observatories = parse_mpc_observatories(content)
            print(f"Loaded {len(observatories)} observatories from {obs_file}", 
                  file=sys.stderr)
            return observatories
        except Exception as e:
            print(f"Warning: Could not read {obs_file}: {e}", file=sys.stderr)
    
    # Try downloading if file not found
    if not obs_file or obs_file == 'mpc_observatories.txt':
        observatories = download_mpc_observatories()
        if observatories:
            return observatories
    
    return []


def load_observatory_dates(dates_file):
    """
    Load observatory operational dates from file.
    
    Format: Code StartMJD EndMJD
    Example:
        474 48000 60000
        G96 50000 -1
        
    EndMJD of -1 means still operational
    """
    dates = {}
    
    if not dates_file or not os.path.exists(dates_file):
        return dates
    
    try:
        with open(dates_file, 'r') as f:
            for line in f:
                line = line.strip()
                # Skip comments and empty lines
                if not line or line.startswith('#'):
                    continue
                
                parts = line.split()
                if len(parts) >= 3:
                    code = parts[0].upper()
                    try:
                        start_mjd = float(parts[1])
                        end_mjd = float(parts[2])
                        dates[code] = {
                            'start_mjd': start_mjd,
                            'end_mjd': end_mjd if end_mjd > 0 else 99999.0  # -1 means still active
                        }
                    except ValueError:
                        continue
        
        print(f"Loaded dates for {len(dates)} observatories from {dates_file}", file=sys.stderr)
    except Exception as e:
        print(f"Warning: Could not read {dates_file}: {e}", file=sys.stderr)
    
    return dates


def load_mpc_observatories(obs_file=None):
    """Load MPC observatories from file or download"""
    
    if obs_file and os.path.exists(obs_file):
        # Load from local file
        try:
            with open(obs_file, 'r') as f:
                content = f.read()
            observatories = parse_mpc_observatories(content)
            print(f"Loaded {len(observatories)} observatories from {obs_file}", 
                  file=sys.stderr)
            return observatories
        except Exception as e:
            print(f"Error reading observatory file: {e}", file=sys.stderr)
            return []
    else:
        # Download from MPC
        print("Downloading observatory data from Minor Planet Center...", 
              file=sys.stderr)
        observatories = download_mpc_observatories()
        if observatories:
            print(f"Downloaded {len(observatories)} observatories", file=sys.stderr)
        return observatories


def plot_terrestrial_map(ax, args):
    """Plot terrestrial map features"""
    
    # Add map features
    if args.coastlines:
        ax.coastlines(linewidth=0.5, color='black')
    
    if args.countries:
        ax.add_feature(cfeature.BORDERS, linewidth=0.3, edgecolor='gray')
    
    if args.land:
        ax.add_feature(cfeature.LAND, facecolor='lightgray', zorder=0)
    
    if args.ocean:
        ax.add_feature(cfeature.OCEAN, facecolor='lightblue', zorder=0)
    
    # Plot observatories if requested
    if args.observatories or args.obs_codes:
        observatories = load_mpc_observatories(args.obs_file)
        
        if observatories:
            # Filter by codes if specified
            if args.obs_codes:
                obs_codes_upper = [c.upper() for c in args.obs_codes]
                obs_to_plot = [obs for obs in observatories 
                              if obs['code'].upper() in obs_codes_upper]
                if not obs_to_plot:
                    print(f"Warning: No observatories found with codes: {args.obs_codes}", 
                          file=sys.stderr)
            else:
                obs_to_plot = observatories
            
            if obs_to_plot:
                lons = [obs['lon'] for obs in obs_to_plot]
                lats = [obs['lat'] for obs in obs_to_plot]
                
                # Plot observatories
                ax.scatter(lons, lats, s=50, c='red', marker='^', 
                          edgecolors='darkred', linewidths=1,
                          alpha=0.8, transform=ccrs.PlateCarree(), 
                          zorder=5, label='Observatories')
                
                # Add labels if there aren't too many
                if len(obs_to_plot) <= 50:
                    for obs in obs_to_plot:
                        ax.text(obs['lon'], obs['lat'], f" {obs['code']}", 
                               fontsize=6, ha='left', va='center',
                               transform=ccrs.PlateCarree(), zorder=6)
                
                print(f"Plotted {len(obs_to_plot)} observatories", file=sys.stderr)


def main():
    args = parse_args()
    
    try:
        run_mapplot(args)
    except KeyboardInterrupt:
        print("\n\nInterrupted by user (Ctrl-C).", file=sys.stderr)
        print("Note: Close the plot window to exit cleanly, or use -o FILE to save without displaying.", file=sys.stderr)
        sys.exit(0)
    except Exception as e:
        print(f"\nError: {e}", file=sys.stderr)
        sys.exit(1)


def run_mapplot(args):
    """Main plotting logic"""
    
    # Load configuration file
    config = load_config(args.config if hasattr(args, 'config') else None)
    
    # Apply config defaults where args don't override
    # (Command-line args take precedence over config file)
    if not args.figsize:
        args.figsize = config['display']['figsize']
    if not hasattr(args, 'palette') or args.palette is None:
        palette_name = config['colors']['data_palette']
    else:
        palette_name = args.palette
    
    # Check for astropy in sky mode (default mode)
    if not args.earth and not ASTROPY_AVAILABLE:
        print("Error: Sky mode requires astropy. Install with: pip install astropy", 
              file=sys.stderr)
        sys.exit(1)
    
    # Check that we have either files or catalog or observatories
    if not args.files and not args.catalog and not args.observatories and not args.obs_codes:
        print("Error: Must specify input files, --catalog, or --observatories", file=sys.stderr)
        sys.exit(1)
    
    # Validate solar-relative mode options
    if args.solar_relative:
        # Solar-relative is only for sky mode
        if args.earth:
            print("Error: --solar-relative is not compatible with --earth mode", file=sys.stderr)
            sys.exit(1)
        
        # Incompatible overlays
        if args.galactic_plane:
            print("Error: --galactic-plane is not compatible with --solar-relative", file=sys.stderr)
            print("       (Galactic plane coordinates don't align with solar-relative frame)", file=sys.stderr)
            sys.exit(1)
        
        if args.celestial_equator:
            print("Error: --celestial-equator is not compatible with --solar-relative", file=sys.stderr)
            print("       (Celestial equator doesn't align with solar-relative frame)", file=sys.stderr)
            sys.exit(1)
        
        if args.milky_way:
            print("Error: --milky-way is not compatible with --solar-relative", file=sys.stderr)
            print("       (Milky Way density is in galactic coordinates)", file=sys.stderr)
            sys.exit(1)
        
        if args.poles:
            print("Error: --poles is not compatible with --solar-relative", file=sys.stderr)
            print("       (Coordinate poles are not meaningful in solar-relative frame)", file=sys.stderr)
            sys.exit(1)
        
        if args.grid_coord:
            print("Error: --grid-coord is not compatible with --solar-relative", file=sys.stderr)
            print("       (Solar-relative uses its own coordinate system)", file=sys.stderr)
            sys.exit(1)
        
        if args.plot_coord != 'equatorial':
            print("Error: --plot-coord is not compatible with --solar-relative", file=sys.stderr)
            print("       (Solar-relative uses its own coordinate system)", file=sys.stderr)
            sys.exit(1)
        
        # Must have input files
        if not args.files:
            print("Error: --solar-relative requires input files with MJD, RA, Dec", file=sys.stderr)
            sys.exit(1)
    
    # Validate animation mode options
    if args.animate:
        if not args.files:
            print("Error: --animate requires input files with MJD as first column", file=sys.stderr)
            sys.exit(1)
        
        if not args.output:
            print("Error: --animate requires output file (-o output.mp4 or .gif)", file=sys.stderr)
            sys.exit(1)
        
        # Check output format
        output_ext = os.path.splitext(args.output)[1].lower()
        if output_ext not in ['.mp4', '.gif', '.avi', '.webm']:
            print("Error: Animation output must be .mp4, .gif, .avi, or .webm", file=sys.stderr)
            sys.exit(1)
        
        # Check trail options (can only use one)
        if args.trail_length and args.trail_days:
            print("Error: Cannot use both --trail-length and --trail-days", file=sys.stderr)
            print("       Use --trail-length N for last N points", file=sys.stderr)
            print("       Or --trail-days N for last N days", file=sys.stderr)
            sys.exit(1)
        
        # Check time range options
        if args.start_time is not None and args.stop_time is not None:
            if args.stop_time <= args.start_time:
                print(f"Error: --stop-time ({args.stop_time}) must be after --start-time ({args.start_time})", 
                      file=sys.stderr)
                sys.exit(1)
        
        if args.show_before_start and args.start_time is None:
            print("Warning: --show-before-start has no effect without --start-time", file=sys.stderr)
    
    # Get marker symbol
    marker = MARKERS.get(args.marker, args.marker)
    
    # Create figure and axis/axes
    fig = plt.figure(figsize=args.figsize, dpi=args.dpi)
    fig.patch.set_facecolor(args.bgcolor)
    
    # Check if timeline plot is requested
    if args.show_timeline and args.trail_days:
        # Create two subplots: main map (top) and timeline (bottom)
        from matplotlib.gridspec import GridSpec
        
        # Calculate height ratios
        main_height = 1.0 - args.timeline_height
        timeline_height = args.timeline_height
        
        # Create GridSpec with two rows
        gs = GridSpec(2, 1, figure=fig, height_ratios=[main_height, timeline_height],
                     hspace=0.15)  # Small space between plots
        
        # Create main map axis (top)
        projection = TERRESTRIAL_PROJECTIONS[args.projection]()
        ax = fig.add_subplot(gs[0], projection=projection)
        
        # Create timeline axis (bottom) - regular axis, no projection
        ax_timeline = fig.add_subplot(gs[1])
        ax_timeline.set_facecolor('white')
        ax_timeline.grid(True, alpha=0.3)
        ax_timeline.set_ylabel(args.timeline_ylabel, fontsize=10)
        
        # Set x-axis label based on format choice
        if args.timeline_xlabel_years:
            ax_timeline.set_xlabel('Year', fontsize=10)
            # Will set custom formatter in update_frame
        else:
            ax_timeline.set_xlabel('MJD', fontsize=10)
        
    else:
        # Single plot mode (original behavior)
        projection = TERRESTRIAL_PROJECTIONS[args.projection]()
        ax = plt.axes(projection=projection)
        ax_timeline = None
    
    # Set background color
    if args.facecolor:
        ax.set_facecolor(args.facecolor)
    else:
        # Default to bgcolor (white) for both Earth and sky mode
        ax.set_facecolor(args.bgcolor)
    
    # Set extent if specified
    if args.extent:
        ax.set_extent(args.extent, crs=ccrs.PlateCarree())
    else:
        ax.set_global()
    
    # Add gridlines
    # For sky mode (celestial coordinates), flip horizontal axis to be left-handed FIRST
    # This must happen BEFORE configuring gridlines
    # E should be on the left, W on the right (astronomical convention)
    if not args.earth:
        ax.invert_xaxis()
    
    # Configure gridlines
    if args.gridlines:
        # Determine grid coordinate system
        grid_coord = args.grid_coord if args.grid_coord else args.plot_coord
        
        # Check if we need custom gridlines (different coordinate system)
        if not args.earth and grid_coord != args.plot_coord:
            # Custom gridlines in different coordinate system
            if args.grid_spacing:
                plot_custom_gridlines(ax, grid_coord, args.plot_coord, args.grid_spacing, args)
            else:
                plot_custom_gridlines(ax, grid_coord, args.plot_coord, (30, 30), args)
        else:
            # Standard cartopy gridlines
            # Note: Labels only work well on certain projections (plate-carree, mercator)
            if args.grid_spacing:
                gl = ax.gridlines(draw_labels=False, linewidth=1.0,  # Start with labels off
                                color=args.grid_color,
                                alpha=args.grid_alpha, 
                                linestyle=args.grid_style,
                                xlocs=np.arange(-180, 181, args.grid_spacing[0]),
                                ylocs=np.arange(-90, 91, args.grid_spacing[1]))
            else:
                # Default spacing: 30 degrees
                spacing_lon = 30
                spacing_lat = 30
                
                gl = ax.gridlines(draw_labels=False, linewidth=1.0,  # Start with labels off
                                color=args.grid_color,
                                alpha=args.grid_alpha,
                                linestyle=args.grid_style,
                                xlocs=np.arange(-180, 181, spacing_lon),
                                ylocs=np.arange(-90, 91, spacing_lat))
            
            # Configure label formatting if labels are enabled and projection supports it
            if args.grid_labels and args.projection in ['plate-carree', 'mercator']:
                try:
                    from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter
                    
                    # Apply formatters
                    gl.xformatter = LongitudeFormatter()
                    gl.yformatter = LatitudeFormatter()
                    
                    # Configure which edges get labels
                    gl.top_labels = False
                    gl.right_labels = False
                    gl.bottom_labels = True   # Longitude/RA along bottom
                    gl.left_labels = True     # Latitude/Dec along left
                    
                    # Style
                    gl.xlabel_style = {'size': 10}
                    gl.ylabel_style = {'size': 10}
                    
                except (ImportError, AttributeError) as e:
                    print(f"Warning: Grid labels not available ({e})", file=sys.stderr)
            elif args.grid_labels and args.projection not in ['plate-carree', 'mercator']:
                print(f"Warning: --grid-labels only works with plate-carree and mercator projections", 
                      file=sys.stderr)
                print(f"         Current projection: {args.projection}", file=sys.stderr)
    
    # ANIMATION MODE - separate path
    if args.animate:
        print("Preparing animation data...", file=sys.stderr)
        
        # Prepare sorted time-series data
        all_data = prepare_animation_data(args, palette_name)
        
        if len(all_data) == 0:
            print("Error: No data to animate", file=sys.stderr)
            sys.exit(1)
        
        print(f"Animating {len(all_data)} data points", file=sys.stderr)
        print(f"Time range: MJD {all_data[0]['mjd']:.2f} to {all_data[-1]['mjd']:.2f}", file=sys.stderr)
        
        # Load observatories if animating them
        observatories = None
        obs_dates = None
        if args.animate_observatories:
            if not args.obs_dates_file:
                print("Error: --animate-observatories requires --obs-dates-file", file=sys.stderr)
                sys.exit(1)
            
            observatories = load_mpc_observatories(args.obs_file)
            obs_dates = load_observatory_dates(args.obs_dates_file)
            
            if not observatories:
                print("Warning: No observatories loaded", file=sys.stderr)
            if not obs_dates:
                print("Warning: No observatory dates loaded", file=sys.stderr)
            
            if observatories and obs_dates:
                print(f"Will animate {len([c for c in obs_dates.keys() if any(o['code'].upper() == c for o in observatories)])} observatories", 
                      file=sys.stderr)
        
        # Plot background (static elements)
        if args.earth:
            plot_terrestrial_map(ax, args)
        else:
            plot_sky_map(ax, args)
        
        # Add legend if requested (static, shows before animation)
        if args.legend and args.labels:
            # Create dummy scatter plots for legend - use user colors if provided
            if args.color is None:
                file_colors = get_data_colors(palette_name, len(args.files))
            else:
                file_colors = args.color[:]
                if len(file_colors) < len(args.files):
                    file_colors.extend(['black'] * (len(args.files) - len(file_colors)))
            
            for i, label in enumerate(args.labels):
                ax.scatter([], [], c=file_colors[i], s=args.size, label=label, 
                          marker=MARKERS.get(args.marker, args.marker))
        
        # Add sun to legend if showing sun (even if no data labels)
        if args.legend and args.show_sun and not args.earth:
            ax.scatter([], [], s=100, c='yellow', marker='o',
                      edgecolors='orange', linewidths=1.5, label='Sun')
        
        # Create legend if we have any labels
        if args.legend and (args.labels or (args.show_sun and not args.earth)):
            # Use user's requested position (don't auto-move)
            legend_loc = args.legend_loc
            
            # Position legend with bbox_to_anchor
            # Allow lower positions to extend below axes if needed
            if legend_loc == 'upper right':
                bbox_anchor = (0.98, 0.98)
                loc_anchor = 'upper right'
            elif legend_loc == 'upper left':
                bbox_anchor = (0.02, 0.98)
                loc_anchor = 'upper left'
            elif legend_loc == 'lower right':
                bbox_anchor = (0.98, 0.02)
                loc_anchor = 'lower right'
            elif legend_loc == 'lower left':
                # Position below axes and further left to minimize plot overlap
                bbox_anchor = (-0.05, -0.05)  # Further down and to the left
                loc_anchor = 'lower left'
            elif legend_loc == 'center':
                bbox_anchor = (0.5, 0.5)
                loc_anchor = 'center'
            else:  # 'best'
                bbox_anchor = None
                loc_anchor = 'best'
            
            # Create legend with translucent appearance and high zorder
            # Check for custom handlers (e.g., galactic center ellipse)
            handler_map = {}
            if hasattr(ax, '_gc_legend_handler'):
                handler_map.update(ax._gc_legend_handler)
            
            if bbox_anchor:
                legend = ax.legend(loc=loc_anchor, bbox_to_anchor=bbox_anchor, 
                         bbox_transform=ax.transAxes,
                         framealpha=0.9, facecolor='white', edgecolor='gray',
                         frameon=True, borderpad=0.5,
                         handler_map=handler_map if handler_map else None)
            else:
                legend = ax.legend(loc=loc_anchor, framealpha=0.9, facecolor='white', 
                         edgecolor='gray', frameon=True, borderpad=0.5,
                         handler_map=handler_map if handler_map else None)
            
            # Set high zorder to ensure legend is above data points
            legend.set_zorder(100)
        
        # Add title if requested (on main plot axis)
        if args.title:
            ax.set_title(args.title, fontsize=14, fontweight='bold', pad=20)
        
        # Add cardinal directions if requested
        if args.cardinal:
            plot_cardinal_directions(ax, args)
        
        # Create and save animation
        anim = create_animation(args, ax, fig, all_data, palette_name, 
                               observatories, obs_dates, ax_timeline)
        
        # Determine writer based on output format
        output_ext = os.path.splitext(args.output)[1].lower()
        
        print(f"Saving animation to {args.output}...", file=sys.stderr)
        
        try:
            if output_ext == '.gif':
                writer = PillowWriter(fps=args.fps)
                anim.save(args.output, writer=writer)
            else:  # mp4, avi, webm
                # Use H.264 with CRF for better compression (smaller files, same quality)
                # CRF 23 = default (good), 18 = visually lossless, 28 = acceptable
                # Lower CRF = higher quality & larger files
                # codec_params: preset=medium balances encoding speed vs compression
                extra_args = ['-vcodec', 'libx264', '-crf', '23', '-preset', 'medium', '-pix_fmt', 'yuv420p']
                writer = FFMpegWriter(fps=args.fps, extra_args=extra_args)
                anim.save(args.output, writer=writer)
        except FileNotFoundError as e:
            if 'ffmpeg' in str(e).lower():
                print("\nError: ffmpeg not found!", file=sys.stderr)
                print("", file=sys.stderr)
                print("To create MP4/AVI/WebM videos, you need ffmpeg installed:", file=sys.stderr)
                print("", file=sys.stderr)
                print("  macOS:           brew install ffmpeg", file=sys.stderr)
                print("  Ubuntu/Debian:   sudo apt-get install ffmpeg", file=sys.stderr)
                print("  Red Hat/Rocky:   sudo yum install ffmpeg", file=sys.stderr)
                print("", file=sys.stderr)
                print("Alternatively, use GIF output (doesn't require ffmpeg):", file=sys.stderr)
                print(f"  ./mapplot-with-animation --animate {' '.join(args.files)} -o output.gif", file=sys.stderr)
                sys.exit(1)
            else:
                raise
        
        print(f"Animation saved to {args.output}", file=sys.stderr)
        return  # Exit - animation saved, don't do static plotting
    
    # STATIC MODE - normal plotting (unchanged)
    # Plot appropriate map type
    if args.earth:
        plot_terrestrial_map(ax, args)
    else:  # Sky mode (default)
        plot_sky_map(ax, args)
    
    # Default colors if not specified
    if args.files:
        if args.color is None:
            # Use color palette from config or command line
            args.color = get_data_colors(palette_name, len(args.files))
        elif len(args.color) < len(args.files):
            args.color.extend(['black'] * (len(args.files) - len(args.color)))
        
        # Default labels if legend requested but no labels specified
        if args.legend and args.labels is None:
            args.labels = [f'Dataset {i+1}' for i in range(len(args.files))]
    
    # Track if we have a colormap for colorbar
    has_colormap = False
    scatter_obj = None
    
    # Plot data from each file
    if args.files:
        for i, filename in enumerate(args.files):
            mjd, coord1, coord2, sizes, colors, labels = read_data(
                filename, 
                ignore_extra=args.ignore_extra,
                labels_from_file=args.labels_from_file,
                solar_relative=args.solar_relative
            )
            
            # Handle solar-relative coordinates
            if args.solar_relative:
                if mjd is None:
                    print("Error: --solar-relative requires MJD as first column", file=sys.stderr)
                    sys.exit(1)
                
                # Convert to solar-relative ecliptic coordinates
                coord1, coord2 = compute_solar_relative_coords(
                    mjd, coord1, coord2, args.input_coord, args.solar_center
                )
                
                # Solar-relative mode always plots in ecliptic-like coordinates
                # coord1 is now solar-relative longitude, coord2 is ecliptic latitude
                # No further transformation needed
            else:
                # Transform coordinates if in sky mode (non-solar-relative)
                if not args.earth and args.input_coord != args.plot_coord:
                    coord1, coord2 = transform_coordinates(
                        coord1, coord2, args.input_coord, args.plot_coord
                    )
            
            # Adjust coordinates for certain projections
            if args.projection in ['mollweide', 'hammer', 'aitoff']:
                coord1 = np.where(coord1 > 180, coord1 - 360, coord1)
            
            # Determine sizes
            if sizes is not None:
                s = sizes * args.size
            else:
                s = args.size
            
            # Determine colors
            if colors is not None:
                c = colors
                cmap = args.cmap
                has_colormap = True
            else:
                c = args.color[i]
                cmap = None
            
            # Get label
            label = args.labels[i] if args.labels and i < len(args.labels) else None
            
            # Plot
            scatter = ax.scatter(coord1, coord2, s=s, c=c, marker=marker,
                               alpha=args.alpha, transform=ccrs.PlateCarree(),
                               edgecolors=args.edgecolor, linewidths=args.edgewidth,
                               cmap=cmap, label=label, zorder=2)
            
            # Add text labels if requested
            if labels and args.labels_from_file:
                for j, (x, y, lbl) in enumerate(zip(coord1, coord2, labels)):
                    if lbl:  # Only plot non-empty labels
                        ax.text(x, y, lbl, fontsize=8, ha='left', va='bottom',
                               transform=ccrs.PlateCarree(), zorder=3)
            
            if has_colormap:
                scatter_obj = scatter
    
    # Add colorbar if requested and we have color data
    if args.cbar and has_colormap and scatter_obj is not None:
        plt.colorbar(scatter_obj, ax=ax, orientation='horizontal',
                    pad=0.05, shrink=0.8, label='Color Value')
    
    # Add cardinal direction markers if requested
    if args.cardinal:
        plot_cardinal_directions(ax, args)
    
    # Add legend with translucent appearance and high zorder
    if args.legend or (not args.earth and (args.catalog or args.ecliptic or args.galactic_plane)):
        # Check for custom handlers (e.g., galactic center ellipse)
        handler_map = {}
        if hasattr(ax, '_gc_legend_handler'):
            handler_map.update(ax._gc_legend_handler)
        
        legend = ax.legend(loc='best', framealpha=0.9, facecolor='white', 
                 edgecolor='gray', frameon=True, borderpad=0.5,
                 handler_map=handler_map if handler_map else None)
        legend.set_zorder(100)
    
    # Add title with extra padding (on axis)
    if args.title:
        ax.set_title(args.title, fontsize=14, fontweight='bold', pad=20)
    
    plt.tight_layout(pad=1.5)  # Add more padding around the plot
    
    # Save or show
    if args.output:
        plt.savefig(args.output, dpi=args.dpi, bbox_inches='tight', 
                   facecolor=fig.get_facecolor())
        print(f"Saved to {args.output}")
    else:
        print("\nDisplaying plot... (Close the plot window to exit)")
        plt.show()


if __name__ == '__main__':
    main()
